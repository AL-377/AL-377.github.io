<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《Paper Reading》ToolDec:SYNTAX ERROR-FREE AND GENERALIZABLE TOOL USE FOR LLMS VIA FINITE-STATE DECODING</title>
    <link href="/2023/10/13/paper-ToolDec/"/>
    <url>/2023/10/13/paper-ToolDec/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="81bc7cc7a3026823d498ff080cf8c3d9cd539f678ffcc9b1831e5731c13fba57">8d8288463184cbc6310d2068d8771019181f148b225656057eac4e1e371446f79825fa00c544a90113382d972b58cb48d76a33f8a45504196b3e6633f13437617259628d8058feb1de98eed9dcbf899571c062bb22c3f96eb126b83f0b9f2a7d85c3e56257e85a15684e119802957d046fd19f23f8dca7dcc00a39b4ded44bb7b2666b8a34cdb262446cc5dbd552c530304e3a7e3a0d7ff08a6e48d6fc46d04a0f15624144cc411bd13a682bf4aea36dbb6d5b220831b80d2ce402dc6a2d954a026b1ae21e86ebb4a51a819bbcf29793c3011222fa027e3d8a65a04c3bbccba9a2c40dba160c76a5488cc9629d3e27ff3ced2a957b625ccfa19afcb5aa4383f70f4e259e4c09078435918195d489df6d648e3f70c1b5f0923e8ae0c423607baaa9362b531153439885ee09ea4a83a69d38ca78e833deeaa723fa757b0509863cf89f98d44b1eb794b45e12b6fdcdd498538802ed29ac6366106427900a5b8453f70d07cba9b58bc569b0e6a09b8d076ff24f1623c7e1697ca4f7d590b42022703cc66646c836f4e9d1372ac3ae707c8bdd552538eb388888a2ff0d75df044ab1450f9e3c348e9c85f571c5282637f3710e192e6ead0578e94c763db86cd0d0f7ac42a759c31f6cb98593013878d918b5f107ea8fd6eb3428e1dfc2a876094314da342e8179ee190804fd784cbeac8733ff883f7f6c25f32472443f0e637e589de58ebf5b40b89e15296e22e7afba3f00e3a9e2ef3c67b7d4a3664bff43228b2bd3b729f1d43df426eb1392d86310f2c67c95272640d3471fb065b695de797b3606dbe2ada188d21611b891cb11df741ac47e4f249acc8757f8dade82a88034ea294844f4470b157d0fa3e6f6b6a6954281899d95a4e2450b6f880a0d5e772566445bbea6b494a921acdda7fd21ea0397a116900ee841ae70cc237a86905dd2b3b4a963faaae4f49ac09f50499b386ab61666292795cd1a84fc4b694858a7d878c2660c356f0fa1b7596bf1280f6363f822ce3da423d80f2521fe3b871b4839503550c5ef49525b8b6d898c4333bc75f57176d25369d310cc8013bb6ba9d3dd407911e25a1f5994d98807ab8f0fbce9fabef6676b76b29b1fde16f4d27c9cd95fcf844e30a959fd91dfec0ef3926845f6921b734a2e88e04856c105a0f2d9712fa356ac1095d073ee1ba49945b29044d309944cb8a4d8f9b6e406e2a4b362155f2971e57b8de76fe8b61e14be117f3bb7f4b9bc4cf5fe92fb6740e572e244da628f8d24d5e139268585e48a850c5005a359b8a6204ab061df77c0968fd8868454441c8678077b7dc6264328a2bd1a6a8388a2aec4713feba6f9d2e436b42460649d004862c99d0d31fab56eb03f0d7c176438b22c2474ad50677ebf4dd58d22478194fc9948699750b58a4d398f5eac398b85234df97b4ed4d3a08492dc750adeba20b00f2f174078478f5a499df3047b05fa6e0bbb2b4642feea897d9627b5cbbbf3234305f455cdd6a65a8c916acac0727496c705ea05ced8df8b1e1f29a07d20433622abd354604a12dad9e2a35fd9bf7e66c16d5b45c80813dc6d1608fa516be9da58f4a852d7cd4152e98f28c1de3f809a8cfeffc383ef14f4907ff24c6153a165fe98c04b693f8dc22e1df526e5c0ddd0865bb93108bf12a3ccda09302f95db930a99c0aab2405be605fa590838bd10ae4c99942f0253f472f60fb0eb163e693d9300d2eee0a576c49d2f63801a039a27196881890cdabbe1cec746b7fe0d7f6cd809756642a102954d2c6aa17c0559b4f9e7f517238ad0634c8d0cb939cde7a6f74923e5347835ff30f3a8cf746dbf81bbb5e6486146d1214192055bb784e65f44302695f3933eb01d2db33a286a1d47a6ce57359bd844152e86753f02efc52a507029e40e641411f9fed488416d742f22682794a8d47e04e9d10553d67c6acf464c46b8669a539a4975905acbd7ebc127d2f85b97492993278deeebeab84f212dec2570d4bf7e036e6dcd4675efd15e1e2526537b1ebba33c3deb85cbbc826ca90f1a6255b3bbeb5052ab2d5cd19041c20f94c62d2011e2ccdd4805bc97822d2ba7e7f0d6b4c0d25f255e48d041b332ae75b68e7b2b4d4e64af1e9b4fcc2d6d0f8c87c7c6c839b67928be244644d7d4830706ea2830e10dd4d7c7a33378553ac71c2913640f89f113e55884c7687735f4baf58ab54cc3b58e583027c2666b57ade38919e90bbe810cbbedc90a1a09c83767c7ef37fa8d96b55f8201fad6893174aec04cada77b593267e860505404bbb13ed042587533cf6417882de7e77a3c1f3d05630c9b19f3c5ad55bdec23ff42620a3ce24ff69ec2b3debe2e64a4d5dc71bf813a9ca2cac77b9449b56b3133c0a0def05456b86ef049c368ebea7c39dbbef11e93fd2eba6c36d53388cbe7571c97da4a7099ed9dd6b670f59102e7fecda892c86c251d2d919c6d78533da40ead1b7d83f09d036d08f9a91c7f6a4d9bf082578bcd6741b3e3968b77dafb4cfb51f49081324489f0e4923d5d7998be5311fdf65a53e6af82052c5ae84dbb10eb6de36a9994cf8d7b8b0a11d9849105d12675b1a19549a5bace74ea05c82aee8bc2480904300357d5195419279a0be3c1b830d933a8ebe5ba711ad83d6af5fc708f52b357470d5372525883f4ab62d7655adb5e4d55f2777e0288abac6cd2377a559cb21c016d7acb916195eff6b40786ace54eeef97a529b14fefac91d8a0db85e0e34415a83428a6a7c26c40c468370a189c1d1566fbb2251713c42d0d0f076c1ff50cfc7286099eb345716ec1669bd3b9e8589f886e5276d3e3fefc687a537e98ea016f97a25422b852f8ef3aaf7fe59417baf7fd4518c33a562d6afba91bfd39817f0e803fd59d931a469e523e9661709ff43369e6ad58f64bdf8032e2b756de3a8f1b209887cc470376eefd4cab230cedd1a41c75e833ef57aa753a49d9bb0204aff956c3f1d9e532f1306acba68c438037da086461db9a4152ca4fd30c58fafb755ad002c019948b5a97c5b019e11b953b8e992c36d0b923c1c3d292655f9bd443debb007ae9c67b28bdd9b9f23fb30cee0d11c37f5792cbeb534cf7f36d32e217172791d454d356ea938c393d63c43770940bef11db5327f581d8b6af6f1b35467840ee1f237f3f76dc8dc7736fa3ad6bb59422f5ae87fb1c8318ce59ab296b2177154f6f4cdf977aa154f019bec93335475b30705c6e4e0839930b044ba241fe9fdd625eb79f19a360af718643085a756352e9a475556ff6340428a546d6ad15edce5e60331c74aeb70443475f83646b132b825dc2196c994ed6087c77a2779193e66b3edecc4509305d57f8359aec94bfca3629c38329da427ca1cffc560937a2599486244257b4aea74e3e18c614bf429d117d45bfd33e71e19330939e56e7a3a7043e90368a8326bf4d66691c7c766cb41142ac5b2fac86dc7043aba004aef5f1b2bb9419389d3be140d88363031a5bc708fc27b2cffb5f2aa861fe4838a99454c469366ae7b8624aa72ec39a9338411f580f131b7f43e7c99614f8ead3272234ec3bea67795816b280c8577b96ac9661a24188d818b1f2aa8a91a4b6406086d8064dc5974d52d8d3591358f03770f715a936ce2eed2ae604cadd1ae45d64099b580415811cdbb067b1db28cb9848f312ca7c352d95b337719eabe5a5580ad559b51a8a5ce3cb58444f4b5fc5d4cf1ec3a39cc13546c3e6003a2e6c47d0ea42b4b496fd297a64cdc164ef3700b7fc30b981166668a36a597228019131d1e700cd30f5e17fee3871d0bd5bde229428139386bf55534ae461660fd07d0e8dca68c79b22b68cea3d0d360d753790dd7ee08536342f0b34d2deb74a5a1ea2749987f9aed8a0fc058eec9890aaa17b54578e928b2b14566c5c5eb2da21641d8226909f35c42831011a96fef0d71c6f68ea9a942e168e1104fff8e0084d653ad7f14e73cf2322aae1ac6c45f612ec70cf55004d8647dbf217059159f810ad5f5566ed1bdb5be78b828fbd2a4b0c1fd22b06d737f74a5143adf9e4dabaa1ad279da3ac56fcdbca65ac9c1b57f18f6077617bb8ccbc6f28b4eb9e4ef37c73d5fabc1cc8f5c7156964c8e853dbc154d5bc87b74b2280a8e366753c5fe94ed8394d213c239b3cfab784babe10d45e5b30b178dc7b95388ff3a07b20d4cedc42fbdbf01bb3b0b940bb0b2b8f01bd29a06880024cf4313e7a83cd98a3073c0d93307c31e01b4c2f19b10341e3f0b05a8f0cc48e4f757eef25f18d6bcacaf129f48628763788000985b988cd814c7e86cfc0833fcdfe9b725498cdadaeddcd2b03dfbac6f0609564e93ddf1cfcf7282c3ffbf8cec029dd2d06d8bf3e601389a0cd1dd407de4fda4cae476a2abda3c699b0d77969a14479fbe2960883e6a9c811beb94e2d3505b66979a72ca9fce4b12571aec9b348f9debd53b0aec10e6238d1ffefaa461d106dc37da980463b333c133e63677057ecf4bb8a109bb090ea9140904acf0f91c977fa95ef24b72f6481d57d6048f70e7cdcaa4e47183100ae1835684a3b5ea9965610a6b4660ac0d5da88c262d5651cbe7c0bd1fb5946de9cdc349bbe2a804586ee0f239343cd6ef8d7de76822c65e622ff815614f626167d95e1a3f07f7d2d1211d266d44e98d354d80146b4fe94b626897b4f8f2e69d3035ca768e2720c7075123c55c0ef049777a95f4290a2831781da379d55fc4afa874461046984f4c2da8e9279ed19fca7c3bc5fec0b1f0be97f637e76856ff1ae0f1a02ac9f5c48675569295a59947704b8b59d6501221474ab9960d43372f1604efa752659d594eacb014d8fd111fa8f33780e137405b9a65a4cabb41318c70fd646df67a0029561a6df2cd7d7f53640810b44be50603f9bb6c5dfe65d0fb8b4fc1925bda0ad34a6d74f708069eb56ad6f8dc8b8c5dc94c244e32d6a73dcaaf24d8229f1d0b11ee5fbb14167c32bd5e8a65d0d0bb4a4f93aa8730239f1230ecd1c82f6bbaa9dda4cd0829f75ea52c4890323b65c2a55208e9b9a98dbb7c620f0467c431af2209e84f3e2e64e15c7c4110a195b0a7c75c39d0dd35e3232fae7672825f179daa300d1383acd7d282232d975f4ee571aebb4f9ccff505b76d9506063a5aa3c0f3a9dd1a228bf741ab5c9d0193e86ae77cd2368de496ab35af7f55694f9309244ed689988a38057355545b2a057835e31c87a90574a1c878029475966c97cc3036c55e7a4ab128af05fe6773a11ee9992cec7978f997a57499c72b32e936381b9882255e0dd073e598d0f720e104e6538c829830bec9ecddb83ab0a9540682eba9ded90bdf56c15c043a18df0ca12c55284fce740844a2bce2b9acee5e02b335fb6c599a64830c32329fa3eb4fff0be8c9877bbf86d225fee94e0ae461b78f6912844718e679666583a23de9425e81d577ed0fa07aff967d4fa478831ae887d9a58534bd2b470fa04a1b814461777b3c87c61acdf247157144dc7c9478aae2911424f5456ae4c2ed641a30886a649515a35593d5b48b71b3cd83c7d5833a0e3de3ec9a460aeae38cd69a3430301907ec6e436e0ff20896d259b13646505ec97699bc3619f5c0b40be161cda302014d73bdb115f6a929b8c93748d72abafd88141b125bf986a1121a82c583233fff0ca60ad7cbe8da8a039e0ff3bff9e90398785ecde728ba030fe7c75f7e91142add94e29de92339bdb3302cd514bab0408238f3eb301107f38cab6ddf276563c6b5f8b03e6be05f377a480ad2a8308aaf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>LLM</category>
      
      <category>guided generation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ToolDec</tag>
      
      <tag>FSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Paper Reading》Efficient Guided Generation for Large Language Models</title>
    <link href="/2023/10/13/paper-outlines/"/>
    <url>/2023/10/13/paper-outlines/</url>
    
    <content type="html"><![CDATA[<h2 id="background">Background</h2><h3 id="guided-generation">Guided Generation</h3><ul><li>We want the LLM generation in a human-specified format</li><li>Other than prompt, need to figure out more efficient end effectiveways</li></ul><h3 id="temp-solutions">Temp solutions</h3><blockquote><p>fromhttps://medium.com/productizing-language-models/guided-text-generation-with-large-language-models-d88fc3dcf4c</p></blockquote><h4 id="prompt-engineering-and-output-parsers">1.Prompt engineering andoutput parsers</h4><h5 id="typical">Typical</h5><ul><li><ahref="https://python.langchain.com/docs/get_started/introduction">Langchain</a></li></ul><h5 id="methods">Methods</h5><ul><li><strong>Format instructions</strong>: A method that returns a stringcontaining instructions for how the output of a language model should beformatted.Here can use the pydantic model and "schema"function（generate the json schema）<ul><li>Input the pydantic model format, get the instructions</li><li>refer to the <code>get_format_instructions</code> in <ahref="https://github.com/langchain-ai/langchain/blob/master/libs/langchain/langchain/output_parsers/pydantic.py">implementationexample in LangChain</a></li></ul></li><li><strong>Parser</strong>: A method that takes in a string (assumed tobe the response from a language model) and parses it into somestructure.<ul><li><strong>Regex to find the json</strong></li><li>parse the json into a object（pydantic_object.parse_obj）</li></ul></li></ul><h5 id="benifits">Benifits</h5><ul><li>support any LLM (black box)</li><li>Automatically generates the output instructions.</li><li>Parses the generated JSON string into the model</li></ul><h5 id="limitations">Limitations</h5><ul><li><p>Json output is no guaranteed,since it's key in the first step(before the parser)</p></li><li><p>the more complex is the schema ,the more chances for the model tomake mistake</p></li><li><p>context size too large for the instructions containing longschema desciption</p></li></ul><h4 id="fill-in-values-only">2. Fill in values only</h4><h5 id="typical-1">Typical</h5><ul><li><a href="https://github.com/1rgs/jsonformer/">JsonFormer</a>：awrapper around Hugging Face transformers that fills in these fixedtokens during the generation process and only delegates the generationof content tokens, the actual field values to the language model</li></ul><h5 id="methods-1">Methods</h5><p>The idea behind this method is to guide the text generationmonitoring the logits and tokens sampling.Support 4 types:</p><ul><li>Generating <strong>booleans</strong> : compares logits for<strong>true</strong> and <strong>false</strong></li><li>Generating <strong>numbers</strong>: squash logits for non-digittokens before sampling</li><li>Generating <strong>strings</strong>: stops generation on second<strong>”</strong></li><li>Generating <strong>arrays</strong>: compare logits for “[“, “,”,“]”</li></ul><h5 id="benifits-1">Benifits</h5><ul><li>Efficiency. By generating only the content tokens and filling in thefixed tokens, this method is more efficient than generating a full JSONstring and parsing it.</li><li>Flexible and extendable. This library is built on top of the HuggingFace transformers library, making it compatible with any model thatsupports the Hugging Face interface.</li><li>supports JSON schemas with nested objects.</li><li>available in small and less capable LLM</li></ul><h5 id="limitations-1">Limitations</h5><ul><li><p>currently only supports a limited subset of JSON Schema types(number, boolean, string, array, object)</p></li><li><p>project is not actively maintained</p></li></ul><h4id="transform-the-geneation-task-into-a-finite-state-machine-transition">3.Transform the geneation task into a finite-state machine transition</h4><h5 id="typical-2">Typical</h5><ul><li>Outlines（this work）</li></ul><h5 id="methods-2">Methods</h5><ul><li>Transform the geneation task into a finite-state machinetransition</li><li>modify the logits by mask the invalid token each time</li></ul><h5 id="benifits-2">Benifits</h5><ul><li>The approach is model agnostic as long as you can mask the logits.Open-source LLMs can be used.</li><li>Integration with HuggingFace transformers models.</li></ul><h5 id="limitations-2">Limitations</h5><ul><li>it does not support APIs like OpenAI due to API limitation<ul><li>https://github.com/outlines-dev/outlines/issues/227</li></ul></li></ul><h4 id="domain-specific-language">4. Domain Specific Language</h4><h5 id="typical-3">Typical</h5><ul><li><ahref="https://github.com/guidance-ai/guidance/tree/main">Guidance</a>:provides a Domain Specific Language (DSL) for prompting. It mergestemplating and logic control making it possible to have more complex andclever prompts</li></ul><h5 id="methods-3">Methods</h5><ul><li>to do</li></ul><h5 id="benifits-3">Benifits</h5><ul><li><p>It provides a powerful Domain Specific Language for promptingmaking it easy to build the template for a JSON response.</p></li><li><p>doesn’t work well with small LLMs</p></li></ul><h2 id="reference">Reference</h2><p>[1] Prompting is programming: A query language for large languagemodels</p><p>[2] CODEP: Grammatical Seq2Seq Model for General-Purpose CodeGeneration</p><p>[3]https://medium.com/productizing-language-models/guided-text-generation-with-large-language-models-d88fc3dcf4c</p><p>[4] https://docs.pydantic.dev/latest/concepts/models/</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>LLM</category>
      
      <category>guided generation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FSM</tag>
      
      <tag>Outlines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统安全的重要性</title>
    <link href="/2023/10/09/OS-Virtualization-Security-lesson5/"/>
    <url>/2023/10/09/OS-Virtualization-Security-lesson5/</url>
    
    <content type="html"><![CDATA[<h2 id="攻击类型">攻击类型</h2><blockquote><p>硬件、软件、通信、人</p></blockquote><ul><li>恶意代码(Malicious code)－木马，病毒，逻辑炸弹，蠕虫，天</li></ul><p>窗/后门, 隐蔽通道等. (参见教材P1-3)</p><ul><li>系统渗透(System penetration)－未授权访问系统资源</li><li>中间人(Man in the middle)-攻击者将自己置于用户和系统之间</li><li>拒绝服务(Denial of service)</li><li>使得一个可用服务变得不可用</li><li>网络嗅探(Network sniffing)-攻击者监听网络流量</li><li>信息泄露(TEMPEST)－从电磁辐射中抽取信息</li><li>社会工程(Social engineering)- 为了达到攻击目的而欺骗人</li></ul><h2 id="安全与可信">安全与可信</h2><h3 id="可信系统的建立">可信系统的建立</h3><ul><li>逐层做安全</li><li>不能在不安全的层上做安全应用</li><li>例子：老鼠吃点心例子，如何保护点心？<ul><li>用堵门堵口保护房子，保护的成本高和可信度不够</li><li>用金属盒保护点心，金属盒是一个可信的保护机制</li></ul></li></ul><h3 id="安全系统的定义">安全系统的定义</h3><blockquote><p>可以用状态机来验证</p></blockquote><ul><li><p>1）它是从一个授权状态（或安全状态）开始的</p></li><li><p>2）它不会进入一个未授权状态（或非安全状态）</p></li></ul><h3 id="可信系统vs安全系统">可信系统VS安全系统</h3><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20231009093638947.png" alt="camparison of secure and trusted" style="zoom:50%;" /></p><ul><li>安全是0和1，可信是有程度的被量化的</li><li>安全一般用特性来描述，可信是需要证明的</li></ul>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Virtualization</tag>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker入门</title>
    <link href="/2023/10/08/docker-intro/"/>
    <url>/2023/10/08/docker-intro/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><p><strong>容器（container）</strong>：用沙盒把进程包装起来运行，和其他的进程独立运行</p><ul><li>是一个可运行的镜像实例</li><li>可部署在云端、虚拟机、本地</li><li>支持各种os</li><li>独立于其他的容器，共享同一个os</li><li>云原生的核心技术</li></ul><p><strong>镜像（image）</strong>：为容器运行提供独立的文件系统，包含容器运行所需的所有内容：依赖、配置、脚本、二进制文件等等</p><p><strong>云原生</strong></p><p><strong>从需求产生的技术</strong></p><blockquote><p>As defined by the Cloud Native Computing Foundation (CNCF), Cloudnative technologies empower organizations to build and run scalableapplications in public, private, and hybrid clouds. Features such ascontainers, service meshes, microservices, immutable infrastructure, anddeclarative application programming interfaces (APIs) best illustratethis approach.</p><p>These features enable loosely coupled systems that are resilient,manageable, and observable. They allow engineers to make high-impactchanges frequently and with minimal effort.</p></blockquote><ul><li>可扩展的资源分配，提高运行效率</li><li>不同服务之间的低耦合，提高部署和更新效率</li></ul><p><strong>service meshes</strong></p><ul><li>整合不同微服务的通信框架</li><li>在每一个微服务旁边配置网络代理，统一管控所有的流量</li></ul><p><strong>immutable infrastructure</strong></p><p><strong>microservices</strong></p><p><strong>declarative application programming interfaces(APIs)</strong></p><h2 id="基本原理">基本原理</h2><h3 id="docker整体结构">docker整体结构</h3><h3 id="文件系统">文件系统</h3><h3 id="multi-container">multi-container</h3><h4 id="通信机制">通信机制</h4><p>Netshoot 是一个 Docker容器，包含一套强大的网络故障排除工具。它的作用是帮助用户解决复杂的Docker 和 Kubernetes 网络问题，提供了必要的工具来进行故障排除。</p><p>在使用 netshoot之前，有一个重要的概念需要理解，那就是网络命名空间（NetworkNamespaces）。网络命名空间提供网络相关系统资源的隔离。Docker 和Kubernetes 使用网络命名空间为每个容器或者 Pod创建一个独立的网络环境。在容器或者 Pod的网络命名空间中，所有的接口、路由和 IP 地址都是完全隔离的。</p><p>Netshoot 允许用户在不同的网络命名空间之间切换，从而在其他容器或者 Pod中进行网络故障排除。这在跨多个容器或者 Pod进行网络故障排查时非常有用。此外，netshoot还可以利用主机的网络命名空间来对主机本身进行故障排除，而无需直接在主机上或者应用程序中安装任何新的软件包。</p><h2 id="常用">常用</h2><h3 id="build-and-run-an-image-as-a-container">Build and run an image asa container</h3><ul><li><p>get the app</p></li><li><p>write a <ahref="https://docs.docker.com/engine/reference/builder/">dockerfile</a></p><ul><li>docker参考dockerfile自动build镜像</li><li>实际上，dockerfile里是build时候需要调用的指令（脚本）</li></ul></li><li><p><code>docker build -t self-customized-image-name .</code>build并命名镜像</p></li><li><p><code>docker run -dp 127.0.0.1:3000:3000 self-customized-image-name</code></p><ul><li>-d detach 后台运行docker</li><li>-p 绑定端口，上面这个端口例子publishes the container's port 3000 to<code>127.0.0.1:3000</code> (<code>localhost:3000</code>) on thehost</li></ul></li><li><p><code>docker ps</code> 列出所有container（containerID...）</p></li><li><p><code>docker stop &lt;the-container-id&gt;</code>stop某个container</p></li><li><p><code>docker rm &lt;the-container-id&gt;</code>remove某个container，便可以在app更新以后重新build和run</p></li></ul><h3 id="share-images-using-docker-hub">Share images using DockerHub</h3><blockquote><p>https://docs.docker.com/get-started/04_sharing_app/</p></blockquote><h3 id="persist-db">Persist DB</h3><h4 id="volumes-mount">volumes mount</h4><blockquote><p>https://docs.docker.com/get-started/05_persisting_data/</p></blockquote><p>提供挂载信息，map the specific filesystem paths of the container backto the host machine，挂载的位置docker定</p><h4 id="bind-mount">bind mount</h4><blockquote><p>https://docs.docker.com/get-started/06_bind_mounts/</p></blockquote><p>直接共享文件夹，可以实时看到host的修改，share a directory from thehost's filesystem into the container</p><h3id="deploy-docker-applications-using-multiple-containers-with-a-database">DeployDocker applications using multiple containers with a database</h3><blockquote><p>https://docs.docker.com/get-started/07_multi_container/</p></blockquote><ul><li><p><code>docker network create todo-app</code></p><ul><li>创建网络，便于不同container的通信</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    --network todo-app --network-alias mysql \<br>    -v todo-mysql-data:/var/lib/mysql \<br>    -e MYSQL_ROOT_PASSWORD=secret \<br>    -e MYSQL_DATABASE=todos \<br>    mysql:8.0<br></code></pre></td></tr></table></figure><ul><li>启动mysql container并attach到之前的网络（<ahref="https://hub.docker.com/_/mysql/?_gl=1*yhqkw4*_ga*MjA2NzAxNDI1NS4xNjk2NzQ0NTkx*_ga_XJWPQMJYHQ*MTY5Njc2NjY1Mi41LjEuMTY5Njc2NzU2Ny41OC4wLjA.">mysqldocker配置</a>）</li><li>-v这一行自动volume命名为<code>todo-mysql-data</code>,挂在container的<code>/var/lib/mysql</code></li></ul></li><li><p><code>docker run -it --network todo-app nicolaka/netshoots</code></p><ul><li>container之间的通信需要用到nicolaka/netshoot工具来辅助，首先启动nicolaka/netshoot</li></ul></li><li><p><code>dig mysql</code></p><ul><li>使用nicolaka/netshoot提供的DNS工具查看就知道要连接到什么host-name，可以让新的container连接到mysql</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -dp 127.0.0.1:3000:3000 \<br>  -w /app -v &quot;$(pwd):/app&quot; \<br>  --network todo-app \<br>  -e MYSQL_HOST=mysql \<br>  -e MYSQL_USER=root \<br>  -e MYSQL_PASSWORD=secret \<br>  -e MYSQL_DB=todos \<br>  node:18-alpine \<br>  sh -c &quot;yarn install &amp;&amp; yarn run dev<br></code></pre></td></tr></table></figure><ul><li>启动需要连接mysql的container，并提供相应的mysql参数</li></ul><h3 id="run-applications-using-docker-compose">Run applications usingDocker Compose</h3><blockquote><p>使用 YAML 文件简化多container应用的启动</p><p>https://docs.docker.com/get-started/08_using_compose/</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">node:18-alpine</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">sh</span> <span class="hljs-string">-c</span> <span class="hljs-string">&quot;yarn install &amp;&amp; yarn run dev&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:3000:3000</span><br>    <span class="hljs-attr">working_dir:</span> <span class="hljs-string">/app</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./:/app</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_HOST:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">secret</span><br>      <span class="hljs-attr">MYSQL_DB:</span> <span class="hljs-string">todos</span><br><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">todo-mysql-data:/var/lib/mysql</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">secret</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">todos</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">todo-mysql-data:</span><br></code></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p>[1] https://medium.com/<span class="citation"data-cites="saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504</span></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统与虚拟化安全-虚拟化概述</title>
    <link href="/2023/09/25/OS-Virtualization-Security-lesson4/"/>
    <url>/2023/09/25/OS-Virtualization-Security-lesson4/</url>
    
    <content type="html"><![CDATA[<p>（接intro）</p><h2 id="虚拟化技术分类">虚拟化技术分类</h2><ul><li><p>按照数据中心分，基础设施、系统、软件</p></li><li><p>按照层次分，可以如图</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925095343336.png" alt="image-20230925095343336" style="zoom:33%;" /></p><h4 id="基础设施虚拟化">基础设施虚拟化</h4><ul><li>网络虚拟化：网络的硬件与软件资源整合，向用户提供虚拟网络连接的虚拟化技术</li><li>存储虚拟化：物理的存储设备提供一个抽象的逻辑视图</li><li>系统虚拟化：一台物理机上虚拟出一台或多台虚拟机(VM)</li></ul><h4 id="系统虚拟化">系统虚拟化</h4><p>pool</p><h4 id="软件虚拟化">软件虚拟化</h4><p>Pool</p><h2 id="服务器虚拟化技术">服务器虚拟化技术</h2><h3 id="种体系结构">3种体系结构</h3><h4 id="esx">ESX</h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925101847326.png" alt="image-20230925101847326" style="zoom:50%;" /></p><h4 id="vmware-workstation">VMware workstation</h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925101914213.png" alt="image-20230925101914213" style="zoom:50%;" /></p><h4 id="xen">Xen</h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925101928521.png" alt="image-20230925101928521" style="zoom:50%;" /></p><h3 id="虚拟化实现技术">虚拟化实现技术</h3><blockquote><p>虚拟机系统是通过在现有平台(裸机或操作系统)上增加一个虚拟层VMM(virtualMachine Monitor或Hypervisor)来实现</p></blockquote><h4 id="全虚拟化">1、全虚拟化</h4><ul><li>hypervisor提到0环权限，os换成1环</li><li>全部的指令都交给Hypervisor拦截，并转换处理，不需要改os</li><li>Hypervisor需要做软件模拟，开销大</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925102155008.png" alt="image-20230925102155008" style="zoom:33%;" /></p><h4 id="半虚拟化">2、半虚拟化</h4><ul><li>os的权限环不变，hypervisor也在0权限环</li><li>对特权指令的调用都改成对Hypervisor的调用（hyper call），os修改</li><li>性能优于全虚拟化</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925102522518.png" alt="image-20230925102522518" style="zoom:33%;" /></p><h4 id="硬件辅助虚拟化">3、 硬件辅助虚拟化</h4><ul><li>CPU 额外的多提供了一个环为Hypervisor专用，称为 -1环（硬件实现）</li><li>在操作系统调用特权指令的时候，通过硬件的机制将特权指令调用转到在处在-1环上的Hypervisor 上（os不用修改）</li><li>需要硬件支持（Intel VT和AMD-V）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925103038438.png" alt="image-20230925103038438" style="zoom:33%;" /></p><h4 id="相应的产品对比">相应的产品对比</h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925103151200.png" alt="image-20230925103151200" style="zoom:33%;" /></p><h3 id="vmm实现技术">VMM实现技术</h3><blockquote><p>上一节相当于vmm的实现类型</p></blockquote><h4 id="cpu虚拟化">CPU虚拟化</h4><h5 id="目标">目标</h5><ul><li><p>为每个虚拟机提供 一个或多个 虚拟CPU（VCPU）</p></li><li><p>多个VCPU 复用 物理CPUs,任何时刻一个物理CPU只能被一个VCPU使用</p></li></ul><h5 id="实现">实现</h5><ul><li>模拟执行是指由VMM模拟所有指令的执行效果，包括解释执行和二进制代码翻译执行，效率较低。</li><li>监控执行是指虚拟机的绝大多数指令都在物理主机上直接执行，少量可能影响虚拟机运行或影响其虚拟机状态的指令(敏感指令)必须由VMM监控并模拟其执行效果。执行效率较高。取决于模拟执行指令数量、复杂度和算法性能</li></ul><h5 id="硬件辅助的实现intel-vt-x操作模式">硬件辅助的实现——IntelVT-x操作模式</h5><ul><li>即上文硬件辅助虚拟化具体实现机制，实现根模式、非根模式切换</li></ul><p>pool</p><h4 id="内存虚拟化">内存虚拟化</h4><h5 id="vmm参与时的机器地址定位过程">VMM参与时的机器地址定位过程</h5><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925111332784.png" alt="image-20230925111332784" style="zoom:50%;" /></p><ul><li>在硬件层面用EPT技术实现两次的地址转换（x86只能支持一次地址转换）</li><li>或者用下文的页表虚拟化技术</li></ul><h5 id="页表虚拟化">页表虚拟化</h5><ul><li><p>背景：os通过多级页表建立虚拟地址到物理地址的映射关系</p></li><li><p>整体思路：由VMM 根据映射 f 和 g 生成复合的映射f·g，并直接将这个映射关系交给MMU（Memory Management Unit)</p><ul><li>泛虚拟化方法<ul><li>直接将 f.g 映射关系更新到Guest OS页表项中</li><li>安全隐患大，因为理论上VMM不应该知道guestos到HW的映射（违背了f映射对于虚拟机不应可见的规则）</li><li>例如：Xen</li></ul></li><li>全虚拟化方法<ul><li>guest OS的每个页表维护一个影子页表，并将合成后的映射关系 f·g写入到“影子”中，guest OS的页表内容保持不变</li><li>VMM将影子页表交给MMU进行地址转换</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230925111742019.png" alt="image-20230925111742019" style="zoom:50%;" /></p><h5 id="内存虚拟化的优化">内存虚拟化的优化</h5><p>pool</p><h4 id="io虚拟化">IO虚拟化</h4><blockquote><p>《系统虚拟化：原理与实现》</p></blockquote><h5 id="设备发现">设备发现</h5><h5 id="访问截获">访问截获</h5><h5 id="设备模拟">设备模拟</h5><h5 id="设备共享">设备共享</h5>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Virtualization</tag>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《The Art of Linux Kernel》- Ch1</title>
    <link href="/2023/09/22/The-Art-of-Linux-Kernel-Ch1/"/>
    <url>/2023/09/22/The-Art-of-Linux-Kernel-Ch1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>版本：Linux 0.11</p><p>硬件：IA-32 CPU、16MB 内存（2MB作为虚拟内存）、BIOS中设置软驱作为启动</p><p>（软盘相当于一种可移动的外部存储设备，由于读取速度慢、容量小等原因，目前已经被其他更高效、容量更大的外部存储设备所替代）</p></blockquote><h2 id="通电-main">通电 -&gt; main</h2><blockquote><p>通电-&gt;BIOS启动-&gt;内存中加载中断向量表、中断服务程序-&gt;32位模式</p></blockquote><h3 id="1、BIOS启动">1、BIOS启动</h3><h4 id="找到BIOS">找到BIOS</h4><ul><li>CPU硬件逻辑实现：CS=0xF000 IF=0xFFF0</li><li>BIOS的地址位置：0xFFFF0，固化在主机版的ROM中</li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922144002551.png" alt="开电时，BIOS的状态" style="zoom:33%;" /><h4 id="BIOS加载中断向量表、中断服务程序">BIOS加载中断向量表、中断服务程序</h4><ul><li>启动BIOS以后，开始监测显卡、内存等等，最重要开始加载中断向量表、中断服务程序</li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922144618617.png" alt="image-20230922144618617" style="zoom:33%;" /><ul><li>每个中断向量都指向对应的中断服务程序（实模式的中断机制）</li><li>256个中断向量，每个4字节，2字节IP的值，2字节是CS的值</li></ul><h3 id="2、加载操作系统内核程序">2、加载操作系统内核程序</h3><blockquote><p>分批从软盘的不同扇区加载所有的操作系统程序到内存，为保护模式准备</p></blockquote><h4 id="加载第一批内核代码：bootsect">加载第一批内核代码：bootsect</h4><ul><li>硬件设计+BIOS，出现一个int 0x19中断，对应找到对应的中断服务程序，这个服务程序的作用是将第一扇区的程序加载</li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922150911622.png" alt="image-20230922150911622" style="zoom:33%;" /><ul><li>第一扇区（boot sector）内对应的程序就是引导程序：bootsect（512B）</li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922151502051.png" alt="image-20230922151502051" style="zoom:33%;" /><ul><li>至此，从启动电脑终于接触到了linux操作系统自己的代码（一段汇编），加载到了内存中</li></ul><h4 id="讨论：对于不同操作系统，如何同样方式加载？">讨论：对于不同操作系统，如何同样方式加载？</h4><p>BIOS是写在主机板ROM上的，不管操作系统是啥，对于不同的操作系统类型，采用同样方式加载：</p><ol><li>BIOS接到启动os的指定，固定从启动扇区把程序加载到0x07C00</li><li>操作系统的第一段程序固定放在软盘0盘面0磁道1扇区</li></ol><h4 id="第二部分内核代码：setup">第二部分内核代码：setup</h4><p>boosect的任务是继续加载第二、三批的内核代码，采取以下步骤：</p><h5 id="（1）规划内存（key-in-os）">（1）规划内存（key in os）</h5><ul><li>确保不同的程序、数据不会重叠，有足够的空间安身立命</li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922153024041.png" alt="image-20230922153024041" style="zoom:33%;" /><h5 id="（2）复制bootsect到新的位置">（2）复制bootsect到新的位置</h5><ul><li><p>现在CPU的CS指向的就是BOOTSEG</p></li><li><p>bootsect把自身从BOOTSEG复制到INITSEG（pool）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 56">start:<br>  mov ax，#BOOTSEG<br>  mov ds,ax<br>  mov ax，#INITSEG<br>  mov es,ax<br>  mov cx,#256  (256字就是512B)<br>  sub si,si<br>  sub di,di<br>  rep<br>  movw<br> <br></code></pre></td></tr></table></figure></li><li><p>bootsect直接可以跳转到INITSEG执行了（相当于原来的BOOTSEG位置是约定的位置，不是自己规划的位置），这个时候开始完全摆脱BIOS，根据自己的安排执行</p></li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922161104507.png" alt="image-20230922161104507" style="zoom:33%;" /><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">jmpi <span class="hljs-keyword">go</span>，INITSEG   ！这行之前bootsect已经复制过去到了INITSEG，程序跳转到INITSEG执行了<br><span class="hljs-keyword">go</span>: mov ax, <span class="hljs-keyword">cs</span>  ！在INITSEG新的位置继续执行bootsect代码<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922161722859.png" alt="image-20230922161722859" style="zoom:33%;" /><ul><li>代码整体位置变了，所以代码各个段（寄存器）也会发生变化<ul><li>SS（Stack segment）：指向栈段</li><li>SP（Stack pointer）：栈顶指针</li></ul></li></ul><h5 id="（3）加载setup程序">（3）加载setup程序</h5><ul><li>int 0x13中断，指向磁盘服务程序</li><li>和加载bootect时候的0x19中断不同，0x19对应的服务程序是BIOS执行的，但现在是bootsect执行0x13指向的程序</li><li>0x19对应的服务程序写死，将第一扇区的程序加载到0x07C00，而0x13的程序可以指定扇区的代码加载到指定位置，开始要<strong>传参</strong>了</li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922162147780.png" alt="image-20230922162147780" style="zoom: 33%;" /><ul><li><p>注意此时已经加载5个扇区，且setup.s会加载到INITSEG的位置</p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922162942831.png" alt="image-20230922162942831" style="zoom:33%;" /></li></ul><h4 id="加载第三部分内核代码：system模块">加载第三部分内核代码：system模块</h4><ul><li><p>仍然用0x13的中断</p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922163259030.png" alt="image-20230922163259030" style="zoom:33%;" /></li><li><p>这次加载240个扇区，由bootsect的read_it完成，加载到SYSSEG之后</p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922163439978.png" alt="image-20230922163439978" style="zoom:33%;" /></li></ul><h4 id="Bootsect收尾工作：检查根设备号">Bootsect收尾工作：检查根设备号</h4><ul><li>检查是否设置了根文件系统设备，若没有设置根据不同扇区数设置</li><li>所以linux启动要系统内核镜像、根文件系统</li><li>可以理解到这里，bootsect程序执行完了，接下来是setup的执行</li></ul><h4 id="setup执行">setup执行</h4><ul><li>jump 0，SETUPSEG，跳转到setup程序的位置开始执行</li><li>利用BIOS的中断服务程序，提取内核运行需要的<strong>机器系统数据</strong>：光标位置、显示页面等等，加载到内存对应的位置</li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230922164428132.png" alt="image-20230922164428132" style="zoom:33%;" /><ul><li>加载的位置覆盖了bootsect的程序位置（只留出一个字节空间）</li><li>至此，内核代码加载完全结束，通过已经加载到内存的内核代码，系统将从实模式转变为保护模式</li></ul><h3 id="3、开启32位保护模式">3、开启32位保护模式</h3><h4 id="废除原本的中断机制">废除原本的中断机制</h4><ul><li>关闭中断：关闭直到建立main适合的新的中断服务建立<ul><li>将CPU的标识寄存器EFLAGS的IF置为0（中断不被允许）</li><li>setup.s中的cli和sti分别是关、开中断</li></ul></li><li>移动内核代码到0x00000，覆盖了原来BIOS的中断向量表、数据的区域<ul><li>16位的实模式中断不再适合即将开始的32位linux中断，因此可以回收这块区域了</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230923100014304.png" style="zoom:33%;" /><h4 id="描述符表的准备">描述符表的准备</h4><ul><li><p>全局描述符表：GDT</p><ul><li>唯一存段寄存器内容（段描述符）的数组，配合程序实现段寻址</li><li>所有进程的全局目录，存储每一个任务的局部描述符表（LDT）地址、任务状态段（TSS）地址</li><li>功能：各段的寻址、保护和恢复现场</li><li>GDTR：GDT基地址寄存器，存GDT的基地址，通过LGDTR命令来加载GDT到GDTR</li></ul></li><li><p>中断描述符表：IDT</p><ul><li>所有中断服务程序的入口地址，类似实模式的中断向量表</li><li>IDTR：IDT基地址寄存器</li></ul></li><li><p>比较16位中断和32位中断</p><ul><li>16位的中断向量表固定写死在0x00000的位置，32位利用IDT可以任意放位置，用IDTR来寻址</li><li>在中断重启之前，IDT是一张空的表</li></ul></li></ul><h4 id="打开32位寻址">打开32位寻址</h4><ul><li><p>打开A20地址线，注意物理内存寻址和内存寻址的变化</p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230923102442817.png" alt="image-20230923102442817" style="zoom:33%;" /></li><li><p>内存寻址：直接从5个f变成8个f，32位，4GB的寻址空间</p></li><li><p>物理寻址：16MB（pool）</p></li></ul><h4 id="重新编程8259A">重新编程8259A</h4><ul><li>8259A是一个可编程的中断控制器</li><li>保护模式下，Intel保留了0x00-0x1F作为不可屏蔽中断、异常中断，所以要重新分布中断号</li></ul><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230923103757762.png" alt="image-20230923103757762" style="zoom:33%;" /><ul><li>CR0寄存器置为1，CR0寄存器保存的是PE（protected mode enable，保护模式使能，为0则实模式）</li><li>正式开启保护模式，对比开启前后的寻址变化（pool，P26）</li></ul><h3 id="4、-head-s的执行">4、 head.s的执行</h3><p>p27</p><h2 id="review">review</h2><h4 id="实模式和保护模式">实模式和保护模式</h4><ul><li>实模式，即程序中用到的地址都是真实的物理地址，“段基址:段内偏移地址”产生的逻辑地址就是物理地址，即程序员可见的地址完全是真实的内存地址</li><li>保护模式：随着CPU的位数和寄存器的位数增加，有更安全内存地址定位方式。见<a href="https://zhuanlan.zhihu.com/p/42309472">详细解释</a></li></ul><h4 id="CS和IP">CS和IP</h4><ul><li>CS是代码段寄存器，定义存放代码的存储器的起始地址</li><li>IP为指令指针寄存器，他们一起合作指向了CPU当前要读取的指令地址</li></ul><h4 id="段寄存器">段寄存器</h4><ul><li>pool</li></ul>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统与虚拟化安全-内核导论</title>
    <link href="/2023/09/18/OS-Virtualization-Security-lesson3/"/>
    <url>/2023/09/18/OS-Virtualization-Security-lesson3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.kernel.org/**">配合内核代码结构理解</a></p><p><strong>安全工作重点关注：</strong>不同子组件的系统调用，pool</p><h2 id="内核结构">内核结构</h2><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230918093945084.png" alt="程序调用内核协同" style="zoom:50%;" /></p><h3 id="内核代码结构">内核代码结构</h3><blockquote><p><strong>linux4.19内核代码</strong>：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/?h=v4.19.294</p></blockquote><p>init：开机启动</p><ul><li>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/init?h=v4.19.294</li></ul><p>kernel：进程管理和调度</p><ul><li>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel?h=v4.19.294</li><li>fork.c等等</li></ul><p>ipc：进程通信</p><ul><li>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/ipc?h=v4.19.294</li></ul><p>fs：文件系统</p><ul><li>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs?h=v4.19.294</li><li>vfs是抽象层次封装的文件系统，便于扩展</li><li>鸿蒙的文件系统就是在vfs下实现的分布式文件系统</li></ul><p>include：数据结构的实现</p><p>security：安全部分代码</p><ul><li>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/security?h=v4.19.294</li><li>比如se linux等模块</li></ul><h3 id="文件子系统">文件子系统</h3><h4 id="功能">功能</h4><ul><li>分配文件空间</li><li>管理空闲空间</li><li>控制对文件的存取</li><li>为用户检索数据</li></ul><h4 id="系统调用">系统调用</h4><ul><li>open, creat, close, read, write, state, chown, chmod, link, unlink,mount, umount</li></ul><h3 id="进程控制子系统">进程控制子系统</h3><h4 id="功能-1">功能</h4><ul><li>进程同步</li><li>进程间通信</li><li>存储管理</li><li>进程调度</li></ul><h4 id="系统调用-1">系统调用</h4><ul><li>fork, exec, execve, setuid, exit, kill, wait, brk</li></ul><h3 id="硬件控制">硬件控制</h3><h4 id="功能-2">功能</h4><ul><li>负责处理中断及与机器通信</li></ul><h2 id="文件的内容表示">文件的内容表示</h2><h3 id="inode-table">inode table</h3><blockquote><p>include/inode.c</p></blockquote><h4 id="内容">内容</h4><ul><li><p>包含文件所有者、存取权限、及其存取时间等信息</p></li><li><p><strong>后期做安全权限控制修改的部分</strong></p></li></ul><h4 id="文件索引过程">文件索引过程</h4><ul><li>内核每次分析文件名中的<strong>一个分量</strong>，检查该进程是否有权检索路径中的目录</li><li>并且最终检索到该文件所对应的索引节点。如：<code>open(“/fs2/mjb/rje/sourcefile”,1);</code></li></ul><h4 id="文件创建操作过程">文件创建、操作过程</h4><ul><li>当一个进程建立一个新文件时，内核分配给它一个尚未使用的索引节点，索引节点被存储在文件系统中(即磁盘索引节点表）</li><li>但是当操作文件时，内核将它们读到内存索引节点表中，即：对系统中的每个活动的文件（被某个进程打开了），内存中索引节点表都包含一个条目</li></ul><h4id="对比磁盘索引节点表内存索引节点表">对比：磁盘索引节点表、内存索引节点表</h4><ul><li>磁盘索引节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230918102004538.png" alt="磁盘索引节点内容" style="zoom: 50%;" /></p><ul><li>内存索引节点<ul><li><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230918102202300.png" alt="内存索引节点" style="zoom: 50%;" /></li><li>引用数：open文件的进程数</li><li>内核函数：<ul><li>iget 分配一个索引节点的内存拷贝</li><li>iput 释放一个索引节点的内存拷贝</li><li>namei 把路径名转换为索引节点</li><li>ialloc 把一个磁盘索引节点分配给一个新建立的文件</li><li>ifree 释放一个磁盘索引节点</li></ul></li></ul></li></ul><h4id="对比文件表file-table用户文件描述符表user-file-descriptor-table内存索引节点">对比：文件表(filetable)、用户文件描述符表(user file descriptor table)、内存索引节点</h4><ul><li><p>文件表</p><blockquote><p>include/file结构体</p></blockquote><ul><li>linux内核里全局表，所有进程共享（内核唯一）</li><li>其中的一个条目《=》内核里all进程的open<ul><li>文件偏移量</li><li>访问模式（读、写、or 读-写）</li><li>指向它的文件描述符表的条目计数</li></ul></li></ul></li><li><p>用户文件描述符表</p><blockquote><p>files_struct 结构体</p></blockquote><ul><li>记录某进程所有打开的文件（进程唯一）</li><li>每个进程用一个fs_struct结构体来描述<strong>进程的当前工作目录</strong>及其<strong>所在文件系统根目录下的索引节点</strong></li><li>理解图1：由于文件表条目存储了访问模式（当前读写位置），所以由于A、B进程中对同一个位置的访问模式不同，所以指向不同的文件表条目。</li><li>理解图2：假设B是一个A打开文件以后fork的进程，对应后面的图，不需要再开一个新的文件表条目</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230918103220916.png" alt="理解三张表的关系" style="zoom:33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230918103902793.png" alt="image-20230918103902793" style="zoom:33%;" /></p><h2 id="进程的结构">进程的结构</h2><h3 id="数据结构">数据结构</h3><ul><li>标识号：唯一标识一个进程，用组号标识、用户标识来确定权限<ul><li>真正用户/组标识号：uid，gid</li><li>有效用户/组标识号：euid，egid（真正有效的一组），pool</li></ul></li><li>状态信息：进程当前的状态</li><li>调度信息：如计数器、优先级、调度策略、实时优先级</li><li>通信信息：<ul><li>如信号Signals，管道Pipes，以及内存共享shared memory,信号量semaphore, 消息队列 Message Queues</li><li>进程接到的信号、信号掩码、信号处理函数、为避免死锁而在信号量上设置的取消操作、与信号量相关的等待队列</li></ul></li><li>进程链接信息：<ul><li>进程树中的位置（父子关系、兄弟关系）</li><li>运行队列的位置</li></ul></li><li>时间和定时器</li><li>文件系统信息<ul><li>可执行映像所对应根目录、当前目录的指针（<code>struct fs_struct *fs</code>）</li><li>打开的文件的描述符（<code>struct files_struct *files</code>）</li></ul></li><li>相关上下文信息<ul><li>虚拟内存与物理内存之间的映射信息</li><li>和处理器相关的环境信息，如寄存器、堆栈信息，在进程暂停、恢复是保存和恢复其状态</li></ul></li></ul><h3 id="进程树">进程树</h3><h3 id="进程的标识">进程的标识</h3><h3 id="进程上下文">进程上下文</h3><h3 id="进程表与u区">进程表与U区</h3><h3 id="进程的状态">进程的状态</h3><h4 id="进程的控制">进程的控制</h4><h2 id="进程的通信">进程的通信</h2><h3 id="基本机制">基本机制</h3><h3 id="unix系统v的ipc机制">UNIX系统V的IPC机制</h3><h3 id="系统调用-2">系统调用</h3><h4 id="消息队列">消息队列</h4><h4 id="共享存储区">共享存储区</h4><h4 id="信号量">信号量</h4><h2 id="io-子系统">I/O 子系统</h2><p>​</p>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Virtualization</tag>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统与虚拟化安全-OS基础</title>
    <link href="/2023/09/18/OS-Virtualization-Security-lesson2/"/>
    <url>/2023/09/18/OS-Virtualization-Security-lesson2/</url>
    
    <content type="html"><![CDATA[<h2 id="cpu管理">CPU管理</h2><h3 id="进程调度">进程调度</h3><h4 id="意义">意义</h4><p>​ 线程-资源分配、保护的基本单位</p><h4 id="攻击点">攻击点</h4><ul><li><p>进程调度优先级控制：拒绝服务</p></li><li><p>cpu时间窃取</p></li></ul><h3 id="中断管理">中断管理</h3><h4 id="定义">定义</h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230918085040730.png" alt="中断定义" style="zoom: 50%;" /></p><h4 id="功能">功能</h4><ul><li>实现多道程序设计与并发执行的基础和必要条件</li><li>将CPU（也作为一种资源）分派给不同的进程而实现并发执行</li></ul><h4 id="中断源">中断源</h4><ul><li>中断时机</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230918085510940.png" alt="中断源类型" style="zoom: 33%;" /></p><h2 id="存储管理">存储管理</h2><h3 id="功能-1">功能</h3><ul><li>分配：给用户程序分配运行空间</li><li>扩充：虚拟存储</li><li>保护：隔离不同的用户程序</li><li>共享：用户程序公用数据</li></ul><h3 id="存储体系">存储体系</h3><ul><li>在cache层次解密，提高安全等级</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230918085756979.png" alt="存储体系" style="zoom:33%;" /></p><h2 id="设备管理">设备管理</h2><p>解决不同类型的设备协同</p><h3 id="设备类型">设备类型</h3><h4 id="按资源的占用">按资源的占用</h4><ul><li><p>独占设备：一个时间仅允许一个进程</p></li><li><p>共享设备</p></li><li><p>虚设备</p><ul><li>共享模拟独占</li><li>高速模拟低速</li><li>慢速模拟共享：提高利用率</li></ul></li></ul><h4 id="按数据访问方式">按数据访问方式</h4><ul><li>块设备：常用缓冲-填满再一并处理</li><li>字符设备</li><li>网络设备：by BSD套接口socket</li></ul><h2 id="文件管理">文件管理</h2><h3 id="文件系统">文件系统</h3><p>操纵和管理文件的整套设施</p><h4 id="分类">分类</h4><blockquote><p>下面的数值-文件存储最小单元，即新建文件的初始大小</p></blockquote><ul><li>FAT：32kb</li><li>FAT32：4kb</li><li>NTFS：4kb</li></ul><p>不同的文件系统设计、<strong>对加密的支持不同</strong></p><p><ahref="https://learn.microsoft.com/zh-CN/troubleshoot/windows-client/backup-and-storage/fat-hpfs-and-ntfs-file-systems">对比FAT和NTFS的特点、优缺</a></p><h3 id="文件目录">文件目录</h3><ul><li>对于不同层级的路径进行权限管理、监测</li></ul>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Virtualization</tag>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程</title>
    <link href="/2023/09/17/multi-thread/"/>
    <url>/2023/09/17/multi-thread/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识概念"><strong>基础知识概念</strong></h2><h3 id="进程线程"><strong>进程+线程</strong></h3><p>简单理解： - 进程（process）：任务 - 线程（thread）：子任务</p><p>对比性能： - 创建进程比创建线程开销大 -进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快 -多进程稳定性比多线程高</p><h3 id="多任务程序的模式"><strong>多任务程序的模式</strong></h3><h4id="多进程模式每个进程只有一个线程"><strong>多进程模式（每个进程只有一个线程）</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090339727.png" alt="多进程模式" style="zoom:50%;" /></p><h4id="多线程模式每个进程有多个线程"><strong>多线程模式（每个进程有多个线程）</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090406298.png" alt="多线程模式" style="zoom:50%;" /></p><h4 id="多进程多线程模式"><strong>多进程＋多线程模式</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090426325.png" alt="多进程线程模式" style="zoom:50%;" /></p><h2 id="java多线程编程基础"><strong>java多线程编程基础</strong></h2><h3 id="创建线程"><strong>创建线程</strong></h3><blockquote><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行main()方法。在main()方法中，又可以启动其他线程</p></blockquote><h4 id="步骤"><strong>步骤</strong></h4><ol type="1"><li>实例化一个Thread对象，其run需要定义：<ul><li>方式1：自定义MyThread继承Thread,覆写run</li><li>方式2：创建Thread实例时，传入一个Runnable实例</li><li>方式3：lambda语法</li></ul></li><li>调用对象start方法，而不是run（不会产生新的线程）</li></ol><h4 id="例子"><strong>例子</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式1：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式2：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式3：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>        &#125;);<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程的优先级"><strong>线程的优先级</strong></h4><ul><li>操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行</li><li><code>Thread.setPriority(int n) // 1~10, 增大默认值5</code></li></ul><h3 id="线程的状态"><strong>线程的状态</strong></h3><h4 id="状态类型"><strong>状态类型</strong></h4><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行run()方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；</li><li>Terminated：线程已终止，因为run()方法执行完毕。</li></ul><h4 id="状态间的转移"><strong>状态间的转移</strong></h4><ul><li>不建议使用stop（）函数进行强制的结束</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090458683.png" alt="线程状态转移" style="zoom:50%;" /></p><h3 id="不同线程的交互"><strong>不同线程的交互</strong></h3><h4id="join等待某个线程结束后再执行"><strong>1、join：等待某个线程结束后再执行</strong></h4><blockquote><p>void join() Waits for this thread to die. void join(long millis)Waits at most millis milliseconds for this thread to die. void join(longmillis, int nanos) Waits at most millis milliseconds plus nanosnanoseconds for this thread to die.</p></blockquote><ul><li>一个线程还可以等待另一个线程直到其运行结束。</li><li>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</li><li>例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;[BThread] Thread&quot;</span>);<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(threadName + <span class="hljs-string">&quot; start.&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(threadName + <span class="hljs-string">&quot; loop at &quot;</span> + i);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>            System.out.println(threadName + <span class="hljs-string">&quot; end.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception from &quot;</span> + threadName + <span class="hljs-string">&quot;.run&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    BThread bt;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AThread</span><span class="hljs-params">(BThread bt)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;[AThread] Thread&quot;</span>);<br>        <span class="hljs-built_in">this</span>.bt = bt;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(threadName + <span class="hljs-string">&quot; start.&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            bt.join();<br>            System.out.println(threadName + <span class="hljs-string">&quot; end.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception from &quot;</span> + threadName + <span class="hljs-string">&quot;.run&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(threadName + <span class="hljs-string">&quot; start.&quot;</span>);<br>        <span class="hljs-type">BThread</span> <span class="hljs-variable">bt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BThread</span>();<br>        <span class="hljs-type">AThread</span> <span class="hljs-variable">at</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AThread</span>(bt);<br>        <span class="hljs-keyword">try</span> &#123;<br>            bt.start();<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            at.start();<br>            at.join();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception from main&quot;</span>);<br>        &#125;<br>        System.out.println(threadName + <span class="hljs-string">&quot; end!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中断线程"><strong>2、中断线程</strong></h4><h5 id="方式1interrupt"><strong>方式1：interrupt（）</strong></h5><blockquote><p>void interrupt() Interrupts this thread. static boolean interrupted()Tests whether the current thread has been interrupted.</p></blockquote><ul><li>在其他线程中对目标线程调用interrupt()方法</li><li>目标线程需要<mark>反复检测</mark>自身状态是否是interrupted状态，如果是，就立刻结束运行</li><li>interrupt()方法仅仅向t线程发出了“中断请求”，至于响应要看t的具体实现</li><li>对于调用<code>join()</code>处于等待其他线程状态的某线程，如果突然自己被<code>interrupt（）</code>中断，<code>join()</code>会弹出<code>InterruptedException</code>，所以要及时处理，并停下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        t.interrupt(); <span class="hljs-comment">// 中断t线程</span><br>        t.join(); <span class="hljs-comment">// 等待t线程结束</span><br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloThread</span>();<br>        hello.start(); <span class="hljs-comment">// 启动hello线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            hello.join(); <span class="hljs-comment">// 等待hello线程结束</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;interrupted!&quot;</span>);<br>        &#125;<br>        hello.interrupt();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!isInterrupted()) &#123;<br>            n++;<br>            System.out.println(n + <span class="hljs-string">&quot; hello!&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方式2runningfalse"><strong>方式2：running=false</strong></h5><p>注意点： - 线程中要用 <strong>volatile</strong>标记<code>boolean running</code>，因为这是一个线程间共享的变量，原因如下：-在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。- 如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存 -volatile关键字的目的是告诉虚拟机： -每次访问变量时，总是获取主内存的最新值； -每次修改变量后，立刻回写到主内存。 -volatile关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够<strong>立刻看到</strong> 修改后的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">HelloThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloThread</span>();<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1</span>);<br>        t.running = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标志位置为false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (running) &#123;<br>            n ++;<br>            System.out.println(n + <span class="hljs-string">&quot; hello!&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="守护线程daemon-thread"><strong>3、守护线程（DaemonThread）</strong></h4><blockquote><p>void setDaemon(boolean on) Marks this thread as either a daemonthread or a user thread. The Java Virtual Machine exits when the onlythreads running are all daemon threads. This method must be invokedbefore the thread is started.</p></blockquote><ul><li>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束</li><li>但是有些线程本身就是不会结束的，例如：Java垃圾回收线程就是一个典型的守护线程</li><li>守护线程是为其他线程服务的线程；</li><li>所有非守护线程都执行完毕后，虚拟机退出,即不等待守护线程</li><li>守护线程不能持有需要关闭的资源（如打开文件等）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>t.setDaemon(<span class="hljs-literal">true</span>);<br>t.start();<br></code></pre></td></tr></table></figure><h4 id="线程同步"><strong>4、线程同步</strong></h4><blockquote><p>多线程要解决一个重要问题：数据的一致性</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090748824.png" alt="加锁原理" style="zoom:50%;" /></p><ul><li>这种加锁和解锁之间的代码块我们称之为临界区（Critical Section）</li><li>效果：任何时候临界区最多只有一个线程能执行</li><li>步骤：如何使用synchronized：<ul><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用synchronized(lockObject) { ... }。</li></ul></li><li>注意：<ul><li>加锁、解锁会降低程序效率，所以仅在有数据一致性差异的地方加锁，可以并发的部分不用加</li><li>在使用synchronized的时候，不必担心抛出异常。因为无论是否有异常，都会在synchronized结束处正确释放锁</li><li><ahref="https://xie.infoq.cn/article/2b331b488a9bf5db8b6c59f5f">volatile和synchronized的区别</a>:概括就是volatile可以实现可见性，<mark>但是无法实现原子性</mark>，syn都可以。</li><li><ahref="https://www.cnblogs.com/54chensongxia/p/11910681.html">java原子性介绍</a>：自带原子性的操作不需要用synchronized</li></ul></li></ul><h5 id="synchronized例子"><strong>synchronized例子</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddThread</span>();<br>        <span class="hljs-type">var</span> <span class="hljs-variable">dec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecThread</span>();<br>        add.start();<br>        dec.start();<br>        add.join();<br>        dec.join();<br>        System.out.println(Counter.count);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock) &#123;<br>                Counter.count += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock) &#123;<br>                Counter.count -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程安全的类"><strong>5、线程安全的类</strong></h4><blockquote><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）</p></blockquote><h5 id="定义一个线程安全的类"><strong>定义一个线程安全的类</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            count += n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            count -= n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">var</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Counter();<br><span class="hljs-type">var</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Counter();<br><br><span class="hljs-comment">// 对c1进行操作的线程:</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    c1.add();<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    c1.dec();<br>&#125;).start();<br><br><span class="hljs-comment">// 对c2进行操作的线程:</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    c2.add();<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    c2.dec();<br>&#125;).start();<br></code></pre></td></tr></table></figure><ul><li>这样一来，线程调用add()、dec()方法时，它不必关心同步逻辑，因为synchronized代码块在add()、dec()方法内部。</li><li>并且，我们注意到，synchronized <strong>锁住的对象是this</strong>，即当前实例，这又使得创建多个Counter实例的时候，它们<strong>之间互不影响</strong> ，可以并发执行</li></ul><h5 id="java中线程安全的类">java中线程安全的类</h5><ul><li>Java标准库的java.lang.StringBuffer</li><li>一些不变类，例如String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的</li><li>类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的</li></ul><blockquote><p>大部分类，例如ArrayList，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么ArrayList是可以安全地在线程间共享的。</p></blockquote><h5id="synchronized位置与修饰的目标"><strong>synchronized位置与修饰的目标</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 联系着看上面那个线程安全的类</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 当我们锁住的是this实例时，实际上可以用synchronized修饰这个方法。下面两种写法是等价的：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 锁住this</span><br>        count += n;<br>    &#125; <span class="hljs-comment">// 解锁</span><br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 锁住this</span><br>    count += n;<br>&#125; <span class="hljs-comment">// 解锁</span><br><br><span class="hljs-comment">// 如果static，则锁住的是Counter.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="死锁"><strong>6、死锁</strong></h4><h5 id="可重入锁"><strong>可重入锁</strong></h5><ul><li>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁</li><li>例如下面的例子，add里面调用dec，就是再次获取当前实例的this锁。</li><li><strong>原理</strong>：获取锁的时候，会判断是否是第一次获取，同时记录这是第几次获取。每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>            dec(-n);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count += n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        count += n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="死锁的例子"><strong>死锁的例子</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(lockA) &#123; <span class="hljs-comment">// 获得lockA的锁</span><br>        <span class="hljs-built_in">this</span>.value += m;<br>        <span class="hljs-keyword">synchronized</span>(lockB) &#123; <span class="hljs-comment">// 获得lockB的锁</span><br>            <span class="hljs-built_in">this</span>.another += m;<br>        &#125; <span class="hljs-comment">// 释放lockB的锁</span><br>    &#125; <span class="hljs-comment">// 释放lockA的锁</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(lockB) &#123; <span class="hljs-comment">// 获得lockB的锁</span><br>        <span class="hljs-built_in">this</span>.another -= m;<br>        <span class="hljs-keyword">synchronized</span>(lockA) &#123; <span class="hljs-comment">// 获得lockA的锁</span><br>            <span class="hljs-built_in">this</span>.value -= m;<br>        &#125; <span class="hljs-comment">// 释放lockA的锁</span><br>    &#125; <span class="hljs-comment">// 释放lockB的锁</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上面的代码中，add和dec可能会互相等待对方的锁</li><li>修改方式，将dec中的lockB和lockA交换</li></ul><h4 id="多线程协调方式"><strong>7、多线程协调方式</strong></h4><p>**synchronized + wait*</p><p><strong>Reentrantlock + Condition</strong></p><p><strong>ReadWriteLock、StampedLock</strong></p><p><strong>Semaphore</strong></p><p><strong>Concurrent集合</strong></p><p><strong>Atomic</strong></p><p><strong>线程池</strong></p><h4 id="future结果的返回"><strong>8、Future：结果的返回</strong></h4><h4id="forkjoin任务的拆解"><strong>9、Forkjoin：任务的拆解</strong></h4><h4 id="threadlocal-线程内的上下文"><strong>10、ThreadLocal:线程内的上下文</strong></h4><h2 id="场景案例"><strong>场景案例</strong></h2><h3id="一个线程等待多个并发的线程"><strong>1、一个线程等待多个并发的线程</strong></h3><h4 id="可选的方案"><strong>可选的方案</strong></h4><ul><li>使用 thread.join ()方法，让主线程等待子线程的终止。也就是说主线程的代码块中，如果碰到了t.join ()方法，此时主线程需要等待（阻塞），等待子线程结束了，才能继续执行 t.join() 之后的代码块。</li><li>使用 CountDownLatch类，这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为 0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li><li>使用 CyclicBarrier类，这个类使一组线程相互等待到达一个公共屏障点。在CyclicBarrier类的内部有一个计数器，每个线程在到达屏障点的时候都会调用await () 方法将自己阻塞，此时计数器会减 1，当计数器减为 0的时候所有因调用 await () 方法而被阻塞的线程将被唤醒。</li><li><ahref="https://zhuanlan.zhihu.com/p/139020914">区分CountDownLatch和CyclicBarrier</a>：一句话概括就是前者是1个线程等待多个线程结束再开始，后者是多个线程相互等待到齐了再并发开始</li></ul><h4 id="例子采取countdownlatch-join"><strong>例子：采取CountDownLatch +join</strong></h4><blockquote><p><ahref="https://docs.oracle.com/javase/8/docs/api/">CountDownLatch官方文档</a></p></blockquote><h5 id="场景描述"><strong>场景描述</strong></h5><ul><li>用于将DAG（如下图）的不同节点创建线程，并用DAG的边关系协调线程关系</li><li>有一个主线程，要在所有子线程开始前做一些准备工作</li><li>子线程之间的依赖关系可以建模为DAG图</li><li>子线程完成工作后，主线程做一些收尾工作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090834238.png" alt="gBuilder场景案例" style="zoom: 33%;" /></p><h5 id="说明"><strong>说明</strong>：</h5><ul><li>CountDownLatch用于主线程</li><li>join用于给子线程做一个先后关系的（DAG的有向边）</li></ul><h5 id="代码片段"><strong>代码（片段）</strong></h5><p><strong>1、Scheduler（主线程）</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arrange</span><span class="hljs-params">(DAG dag)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ArrayList&lt;Node&gt; nodes = dag.getNodes();<br>        ArrayList&lt;Edge&gt; edges = dag.getEdges();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(nodes.size());<br>        <span class="hljs-comment">// 便于后面添加线程之间的先后关系</span><br>        ArrayList&lt;WorkerThread&gt; threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// node的id对应的Thread</span><br>        HashMap&lt;Integer,WorkerThread&gt; mit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nodes.size();i++)<br>        &#123;<br>            <span class="hljs-type">WorkerThread</span> <span class="hljs-variable">tp</span> <span class="hljs-operator">=</span> ThreadStore.createThread(startSignal,doneSignal,nodes.get(i));<br>            tp.start();<br>            <span class="hljs-comment">// 将id和thread映射</span><br>            mit.put(nodes.get(i).getId(),tp);<br>            threads.add(tp);<br>        &#125;<br>        <span class="hljs-comment">// 准备工作</span><br>        System.out.println(<span class="hljs-string">&quot;Preparing something for the process of DAG...&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 在这里把对应的Thread之间加一些关系</span><br>        <span class="hljs-keyword">for</span>(Edge edge:edges)<br>        &#123;<br>            <span class="hljs-comment">// 添加前置关系</span><br>            mit.get(edge.getTarget()).addFormer(mit.get(edge.getSource()));<br>        &#125;<br>        <span class="hljs-comment">// 所有没有前置的线程可以开始了</span><br>        startSignal.countDown();<br>        <span class="hljs-comment">// 等所有的线程都完成了</span><br>        doneSignal.await();<br>        <span class="hljs-comment">// 收尾工作</span><br>        System.out.println(<span class="hljs-string">&quot;Finish the whole DAG.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Scheduler</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scheduler</span>();<br>        <span class="hljs-comment">// ? Json2G的具体类型待定，此处简单模拟</span><br>        <span class="hljs-type">DAG</span> <span class="hljs-variable">dag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DAG</span>(Json2G.extractNodes(),Json2G.extractEdges());<br>        <span class="hljs-comment">// execute the DAG</span><br>        sc.arrange(dag);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><strong>2、WorkerThread（子线程）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch startSignal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node node;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;WorkerThread&gt; formers;<br>    WorkerThread(CountDownLatch startSignal,CountDownLatch doneSignal, Node node) &#123;<br>        <span class="hljs-built_in">this</span>.startSignal = startSignal;<br>        <span class="hljs-built_in">this</span>.doneSignal = doneSignal;<br>        <span class="hljs-built_in">this</span>.node = node;<br>        <span class="hljs-built_in">this</span>.formers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFormer</span><span class="hljs-params">(WorkerThread former)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.formers.add(former);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 运行对应的节点的函数</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            startSignal.await();<br>            <span class="hljs-comment">// 等待前面的进程完成先</span><br>            <span class="hljs-keyword">for</span>(Thread former:formers)<br>            &#123;<br>                former.join();<br>            &#125;<br>            <span class="hljs-comment">// 开始进行node的运行</span><br>            node.process();<br>            <span class="hljs-comment">// 锁减少1</span><br>            doneSignal.countDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p>[1] <ahref="https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185">java-廖雪峰</a></p><p>[2] <a href="http://t.csdn.cn/j0SeD">CSDN</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法复杂度优化的技巧</title>
    <link href="/2023/09/17/algorithm-complex-optim/"/>
    <url>/2023/09/17/algorithm-complex-optim/</url>
    
    <content type="html"><![CDATA[<h2 id="一移项法">一、移项法</h2><p>●原理：所谓的移项法，就是将<mark>目标等式</mark>进行左右等价变化，辅助以哈希表/桶，从而减少类似<code>for(j:for(i))</code>的双层循环</p><p>●效果： 将算法从 $ O(n^2) $ 复杂度降低为 $ O(n) $</p><h3 id="使数组和能被p整除"><ahref="https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/2158435/tao-lu-qian-zhui-he-ha-xi-biao-pythonjav-rzl0/">1590.使数组和能被P整除</a></h3><h4 id="前置余数知识">前置余数知识</h4><p>1、<code>( a + b ) % p = a % p + b % p</code></p><p>2、假如<code>( x - y) % p == 0</code> 1.假设<code>x &gt;= 0,y &gt;= 0</code>, 则有 <code>x % p == y % p</code>2.假设上面的某一方<code>x &lt; 0</code>，则有<code>x % p + p == y % p</code></p><h4 id="思路">思路</h4><p>1、利用余数结论，计算<strong>前缀和对p的余数</strong>，则<code>s[n]</code>就表示整体sum对p的余数。</p><p>2、则问题等价于找到 - 2.1、在前缀和数组上找到两个数<code>s[left]</code>和 <code>s[right]</code>，满足<code>right−left</code>最小且<code>(s[right]−s[left]) % p == s[n]</code>- 2.2、<mark>移项</mark>，<code>s[right]−s[n] % p == s[left]</code> -2.3、考虑可能出现正负<code>((s[right] − s[n]) % p + p) % p =  s[left]</code></p><p>3、<mark>避免双层遍历找left和right：</mark>使用一个哈希，存储<code>s[i]</code>出现的最近下标</p><p>4、遍历一遍，到了right，就找哈希里面是否存在left满足 =<code>((s[right] − s[n]) % p + p) % p</code></p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), ans = n, s[n + <span class="hljs-number">1</span>];<br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        s[i + <span class="hljs-number">1</span>] = (s[i] + nums[i]) % p;<br>    <span class="hljs-type">int</span> x = s[n];<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 移除空子数组（这行可以不要）</span><br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; last;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>    &#123;<br>        last[s[i]] = i;<br>        <span class="hljs-keyword">auto</span> it = last.<span class="hljs-built_in">find</span>((s[i] - x + p) % p);<br>        <span class="hljs-keyword">if</span> (it != last.<span class="hljs-built_in">end</span>())<br>            ans = <span class="hljs-built_in">min</span>(ans, i - it-&gt;second);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans &lt; n ? ans : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试题-17.05.-字母与数字"><ahref="https://leetcode.cn/problems/find-longest-subarray-lcci/description/">面试题17.05. 字母与数字</a></h3><h4 id="思路-1">思路</h4><p>1、前缀计数：<code>left1[i]</code>记录到i位置的字母个数，<code>left2[j]</code>记录到j位置的数字个数</p><p>2、思路1：暴力，$ O(n^2) $，看看什么位置满足<code>left1[j]-left1[i] ==  left2[j]-left2[i]</code>,找到最小的i</p><p>3、思路2：<mark>移项</mark>，$ O(n) $，即找到<code>left1[j]-left2[j] ==  left1[i]-left2[i]</code>，那么用<code>map</code>保存当前差值<code>(left1[i]-left2[i])</code>出现的最早位置</p><blockquote><p>当然这题对字母、数字建模为-1，1。可以压缩空间到O(n);且用桶代替map的时间效率更高。 这里重点介绍移项的思想</p></blockquote><h4 id="代码-1">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findLongestSubarray</span><span class="hljs-params">(vector&lt;string&gt; &amp;array)</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; uii;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left1</span><span class="hljs-params">(array.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left2</span><span class="hljs-params">(array.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    vector&lt;string&gt; ansv;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ansp = <span class="hljs-built_in">make_pair</span>(array.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, array.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((array[i][<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; array[i][<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || (array[i][<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; array[i][<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>))<br>        &#123;<br>            left1[i + <span class="hljs-number">1</span>] = left1[i] + <span class="hljs-number">1</span>;<br>            left2[i + <span class="hljs-number">1</span>] = left2[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            left1[i + <span class="hljs-number">1</span>] = left1[i];<br>            left2[i + <span class="hljs-number">1</span>] = left2[i] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= array.<span class="hljs-built_in">size</span>(); j++)<br>    &#123;<br>        <span class="hljs-type">int</span> tp = left1[j] - left2[j];<br>        <span class="hljs-keyword">if</span> (uii.<span class="hljs-built_in">find</span>(tp) != uii.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j - uii[tp] + <span class="hljs-number">1</span> &gt; ans)<br>            &#123;<br>                ansp.first = uii[tp];<br>                ansp.second = j;<br>                ans = <span class="hljs-built_in">max</span>(ans, j - uii[tp] + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j - uii[tp] + <span class="hljs-number">1</span> == ans &amp;&amp; uii[tp] &lt; ansp.first)<br>            &#123;<br>                ansp.first = uii[tp];<br>                ansp.second = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            uii[tp] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ansp.first == array.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ansv;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ansp.first; i &lt; ansp.second; i++)<br>    &#123;<br>        ansv.<span class="hljs-built_in">push_back</span>(array[i]);<br>        cout &lt;&lt; array[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ansv;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计中位数为-k-的子数组"><ahref="https://leetcode.cn/problems/count-subarrays-with-median-k/description/">2488.统计中位数为 K 的子数组</a></h3><h4 id="思路1">思路1</h4><p>0、找到k所在的位置kInd</p><p>1、写出<mark>目标表达式：</mark>: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对于奇数长度的子序列：</span><br>「左侧小于 + 右侧小于 = 左侧大于 + 右侧大于」<br><span class="hljs-comment">//等价于</span><br>「左侧小于 - 左侧大于 = 右侧大于 - 右侧小于」<br><br><span class="hljs-comment">// 对于偶数长度的子序列：</span><br>「左侧小于 + 右侧小于 + <span class="hljs-number">1</span> = 左侧大于 + 右侧大于」<br><span class="hljs-comment">//等价于</span><br>「左侧小于 - 左侧大于 = 右侧大于 - 右侧小于 - <span class="hljs-number">1</span>」<br><br></code></pre></td></tr></table></figure>2、统计kInd左右侧，每个位置到kInd这段子数组中，小于、大于K值的位置数，分别记为smallK、bigK；</p><p>3、用一个哈希记录左侧每个位置的smallK -bigK位置数、右侧bigK-smallK的位置数，然后同时开第2个维度，记录位置的距离kInd的奇、偶。</p><p>4、之后根据不同位置距离kInd的奇数、偶数，可以得到子序列的奇偶，也就可以使用步骤1中的目标表达式，具体见下面代码</p><h4 id="思路2"><mark>思路2：</mark></h4><p>参考：灵神的神级建模，见<ahref="https://leetcode.cn/problems/count-subarrays-with-median-k/solutions/1993439/deng-jie-zhuan-huan-pythonjavacgo-by-end-5w11/">原题解</a></p><h4 id="代码-2">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// （思路1）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> kInd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> bigK;<br>    <span class="hljs-type">int</span> smallK;<br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; leftH;<br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; rightH;<br><br>    set&lt;<span class="hljs-type">int</span>&gt; hasPos;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">if</span> (nums[i] == k)<br>            kInd = i;<br>    <span class="hljs-type">int</span> i = kInd - <span class="hljs-number">1</span>, j = kInd + <span class="hljs-number">1</span>;<br><br>    leftH[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    rightH[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    smallK = <span class="hljs-number">0</span>;<br>    bigK = <span class="hljs-number">0</span>;<br>    hasPos.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 统计</span><br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; k)<br>        &#123;<br>            smallK++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            bigK++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftH.<span class="hljs-built_in">find</span>(smallK - bigK) == leftH.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tp = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            tp[(kInd - i) % <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            leftH[smallK - bigK] = tp;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            leftH[smallK - bigK][(kInd - i) % <span class="hljs-number">2</span>]++;<br>        &#125;<br>        i--;<br>    &#125;<br>    smallK = <span class="hljs-number">0</span>;<br>    bigK = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (j &lt; nums.<span class="hljs-built_in">size</span>())<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (nums[j] &lt; k)<br>        &#123;<br>            smallK++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            bigK++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (rightH.<span class="hljs-built_in">find</span>(bigK - smallK) == rightH.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tp = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            tp[(j - kInd) % <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            rightH[bigK - smallK] = tp;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            rightH[bigK - smallK][(j - kInd) % <span class="hljs-number">2</span>]++;<br>        &#125;<br>        hasPos.<span class="hljs-built_in">insert</span>(bigK - smallK);<br>        j++;<br>    &#125;<br><br>    <span class="hljs-comment">// hash统计位置数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos : hasPos)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (leftH.<span class="hljs-built_in">find</span>(pos) != leftH.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> rOu = rightH[pos][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> lOu = leftH[pos][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> rJi = rightH[pos][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> lJi = leftH[pos][<span class="hljs-number">1</span>];<br>            ans += rOu * lOu;<br>            ans += rJi * lJi;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftH.<span class="hljs-built_in">find</span>(pos - <span class="hljs-number">1</span>) != leftH.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            ans += rightH[pos][<span class="hljs-number">0</span>] * leftH[pos - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            ans += rightH[pos][<span class="hljs-number">1</span>] * leftH[pos - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二剪枝">二、剪枝</h2><p>●原理：广义的剪枝法，就是将没有必要的搜索空间直接跳过，常见于递归问题。但要建立一个剪枝的思想，在各类问题中都适用，<mark>不局限于递归、搜索树。</mark></p><p>●效果： 将算法进行不同程度优化</p><h3 id="最大网络秩"><ahref="https://leetcode.cn/problems/maximal-network-rank/description/">1615.最大网络秩</a></h3><p>参考(关注思路2的分类讨论)：<ahref="https://leetcode.cn/problems/maximal-network-rank/solutions/2167846/zui-da-wang-luo-zhi-by-leetcode-solution-x4gx/">leetcode官方题解</a></p>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旧博客打包部署流程</title>
    <link href="/2023/09/17/old-blog-package-deploy/"/>
    <url>/2023/09/17/old-blog-package-deploy/</url>
    
    <content type="html"><![CDATA[<h2 id="al小站博客简介">“AL小站”博客简介</h2><ul><li>这是一个前后端<strong>不分离</strong>的web项目 , 已失效的链接 <ahref="http://www.yuguang.zone">AL's Blog</a></li><li>前端：semantic-ui组件库，thymeleaf模板引擎</li><li>后端：springboot、mybatis-plus</li></ul><h2 id="前置条件">0、前置条件</h2><ul><li><p>有一台云服务器</p></li><li><p>云服务器上面安全组配置，要打开一些端口号（http、mysql等等对应的不同端口），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917084808737.png" alt="安全组配置" style="zoom:33%;" /></p></li></ul><h2 id="打包步骤">1、打包步骤</h2><h3 id="移除springboot内嵌的tomcat">1.1 移除springboot内嵌的tomcat</h3><p><strong>修改pom.xml文件</strong> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 移除原本自带的tomcat --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 添加servle依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure> ### 1.2 设置打包的方式依旧是<strong>pom.xml文件</strong>，设置打包导出<code>war</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aidan<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>albog-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>albog-server<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h3 id="启动类继承springbootservletinitializer">1.3启动类继承SpringBootServletInitializer</h3><p><strong>修改后</strong>的启动类代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.aidan.alblogserver.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlblogServerApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootServletInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title function_">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.configure(builder);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(AlblogServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="打包成war">1.4 打包成war</h3><p>idea里面依次点击<code>clean</code>-<code>package</code>，如下图："idea中的按钮"</p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917085129130.png" alt="idea操作位置" style="zoom:33%;" /></p><p>工程文件夹下的<strong>target</strong>里面生成了对应的war包。</p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917085217315.png" alt="war包位置" style="zoom:33%;" /></p><p><strong>至此，完成了打包过程。</strong></p><h2 id="服务器环境配置">2、服务器环境配置</h2><ul><li>目标服务器环境（Centos7）</li><li>在<code>war</code>传到服务器之前，先准备好环境，包括以下内容：</li><li>mysql</li><li>jdk</li><li>tomcat</li></ul><h3 id="安装mysql">2.1 安装MySQL</h3><p>卸载Centos7自带mariadb <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找</span><br>rpm -qa|grep mariadb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">mariadb-libs-5.5.52-1.el7.x86_64</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载</span><br>rpm -e mariadb-libs-5.5.52-1.el7.x86_64 --nodeps<br></code></pre></td></tr></table></figure> 解压mysql <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建mysql安装包存放点</span><br>mkdir /usr/server/mysql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar xvf mysql-5.7.34-1.el7.x86_64.rpm-bundle.tar<br></code></pre></td></tr></table></figure> 执行安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到安装目录</span><br>cd /usr/server/mysql/<br>yum -y install libaio<br>yum -y install libncurses*<br>yum -y install perl perl-devel<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>rpm -ivh mysql-community-common-5.7.34-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-libs-5.7.34-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-client-5.7.34-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-server-5.7.34-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure></p><p>修改密码 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动mysql</span><br>systemctl start mysqld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看生成的临时root密码</span><br>cat /var/log/mysqld.log | grep password<br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录mysql</span><br>mysql -u root -p<br>Enter password: #输入在日志中生成的临时密码<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新root密码 设置为root</span><br>set global validate_password_policy=0;<br>set global validate_password_length=1;<br>set password=password(&#x27;root&#x27;);<br></code></pre></td></tr></table></figure> 授予远程连接权限 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;root&#x27;;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新</span><br>flush privileges;<br><br></code></pre></td></tr></table></figure> 控制命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">mysql的启动和关闭 状态查看</span><br>systemctl stop mysqld<br>systemctl status mysqld<br>systemctl start mysqld<br><span class="hljs-meta prompt_">#</span><span class="language-bash">建议设置为开机自启动服务</span><br>systemctl enable mysqld<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看是否已经设置自启动成功</span><br>systemctl list-unit-files | grep mysqld<br></code></pre></td></tr></table></figure> 关闭防火墙 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --state #查看防火墙状态<br>systemctl stop firewalld.service #停止firewall<br>systemctl disable firewalld.service #禁止firewall开机启动<br></code></pre></td></tr></table></figure></p><h3 id="配置jdk">2.2 配置JDK</h3><p>下载JDK，登录官方https://www.oracle.com/java/technologies/downloads/#java8下载所需版本的JDK，版本为JDK 1.8,如图：</p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917085258251.png" alt="jdk下载包" style="zoom:33%;" /></p><p>解压 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zvxf jdk-8u131-linux-x64.tar.gz<br></code></pre></td></tr></table></figure> 编辑 /etc/profile 文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件末尾增加</span><br>export JAVA_HOME=/usr/server/jdk1.8.0_131<br>export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH<br></code></pre></td></tr></table></figure>执行source命令，使配置立即生效 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure> 检查是否安装成功<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure></p><h3 id="安装tomcat">2.3 安装tomcat</h3><p>官网地址：https://tomcat.apache.org/将下载的<strong>apache-tomcat-8.5.86.tar.gz</strong>安装包放在服务器的<code>/usr/home/download</code>目录，并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入/usr/local/download目录</span><br>cd /usr/local/download<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压Tomcat压缩包</span><br>tar -zxvf apache-tomcat-8.5.86.tar.gz<br></code></pre></td></tr></table></figure><p>进入Tomcat的bin目录，启动Tomcat <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入Tomcat的bin目录，启动Tomcat</span><br>cd apache-tomcat-8.5.86/bin/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动Tomcat</span><br>./startup.sh<br></code></pre></td></tr></table></figure>使用浏览器访问Tomcat，地址Linux的ip:8080，若成功可以看到tomcat的欢迎页面，之后在war上传前先关闭tomcat：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">暂时先关闭Tomcat</span><br>./shutdown.sh<br></code></pre></td></tr></table></figure> 配置tomcat环境变量 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br></code></pre></td></tr></table></figure> 最后几行现在变成这样<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export CATALINA_BASE=/home/download/apache-tomcat-8.5.86<br>export CATALINA_HOME=/home/download/apache-tomcat-8.5.86<br>export JAVA_HOME=/usr/server/jdk8/jdk1.8.0_192<br>export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH<br></code></pre></td></tr></table></figure> <strong>记得再source一下配置文件！</strong></p><h2 id="部署过程">3、部署过程</h2><p><strong>注意：当前tomcat处于关闭状态</strong></p><h3 id="删除原本tomcat文件夹下的root目录">3.1删除原本tomcat文件夹下的ROOT目录</h3><p>进入tomcat的webapps文件夹，删除其下ROOT文件夹 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd apache-tomcat-8.5.86/webapps<br>rm -rf ROOT<br></code></pre></td></tr></table></figure></p><h3 id="上传war包到webapps文件夹">3.2 上传war包到webapps文件夹</h3><p>将war上传到webapps文件夹，<strong>修改war名为<code>ROOT.war</code></strong>。启动tomcat： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入Tomcat的bin目录，启动Tomcat</span><br>cd apache-tomcat-8.5.86/bin/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动Tomcat</span><br>./startup.sh<br></code></pre></td></tr></table></figure>此时，会自动解压该war包，生成一个新的ROOT文件夹。<strong>至此，终于完成部署</strong>！通过IP:端口号可以访问博客服务</p><h2 id="tomcat的端口设置">4、tomcat的端口设置</h2><blockquote><p>由于最终是想通过域名进行访问，而不是ip:端口方式，因此后续会进行域名的解析，但是解析无法到解析端口，用户访问域名时会默认访问80端口</p></blockquote><ul><li>方案1：ngnix进行端口转发（略）</li><li>方案2：设置项目的port为80，修改tomcat默认端口由于博主很懒，采用了方案2，步骤如下：</li></ul><h3 id="修改项目application.yml">4.1 修改项目application.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="修改tomcat的配置">4.2 修改tomcat的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">假设已经在tomcat目录，进入tomcat的conf目录</span><br>cd conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑server.xml</span><br>vi server.xml<br></code></pre></td></tr></table></figure><p>将如下几行8080修改为80 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">executor</span>=<span class="hljs-string">&quot;tomcatThreadPool&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>关闭再重启tomcat服务，<strong>完成！</strong></p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微电子前沿技术-Lesson1</title>
    <link href="/2023/09/16/microelectronic-cutting-edge-leeson1/"/>
    <url>/2023/09/16/microelectronic-cutting-edge-leeson1/</url>
    
    <content type="html"><![CDATA[<h2 id="半导体器件">半导体器件</h2><h3 id="分类按产品">分类（按产品）</h3><ul><li>集成电路（比例：市场份额）<ul><li><strong>模拟芯片</strong>（15%）</li><li>数字芯片（85%）</li></ul></li><li>光电子</li><li>传感器</li><li>分立的器件</li></ul><h4 id="国内芯片设计公司产品领域分布">国内芯片设计公司产品领域分布</h4><ul><li>高点：消费类、通信</li><li>增长点：多媒体、计算机芯片</li><li>模拟芯片占比国内12.8%</li></ul><h3 id="模拟芯片">模拟芯片</h3><blockquote><p>*：市场份额最大的</p></blockquote><ul><li>信号链<ul><li>ADC、DAC</li><li>放大器、比较器（*）</li><li>接口芯片</li></ul></li><li>电源链（*）</li><li>射频前端</li></ul><h4 id="电源管理">电源管理</h4><h5 id="功能">功能</h5><ul><li>负责在电子设备系统中对电能进行变换、分配、检测以及其他电能指责的芯片</li><li>将源电压、电流转化为可被微处理器、传感器等负载使用的电源</li></ul><h5 id="分类">分类</h5><ul><li>开关电源（DC/DC，AC/DC）<ul><li>电荷泵-手机快充相关</li></ul></li><li>线性电源<ul><li><ahref="https://zhuanlan.zhihu.com/p/36101543">参考和开关电源的区别</a></li></ul></li><li>电池管理<ul><li>充电管理：手机最佳充电范围 (20%,80%）</li><li>电池保护：和电池管理芯片协同起作用</li></ul></li><li>电源开关<ul><li>负载开关：置于电池、电源和负载之间，只有在系统需要负载时才打开，从而最大限度地减少电力消耗</li><li>低侧开关、高侧开关：相对于外部负载，将半导体<em>开关</em>配置在上侧电路的叫作高边，配置在下侧电路叫作低边</li></ul></li><li>LED驱动</li><li>MOS驱动<ul><li>多应用于工业类的汽车等器件，控制电压率、速度</li></ul></li><li>电机驱动</li></ul><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/36101543<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微电子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商业创新与金融战略-Lesson1</title>
    <link href="/2023/09/15/business-innovation-lesson1/"/>
    <url>/2023/09/15/business-innovation-lesson1/</url>
    
    <content type="html"><![CDATA[<h2 id="新一代的金融业格局">新一代的金融业格局</h2><p>围绕霸权的三大斗争</p><ol type="1"><li><p>科技公司和金融机构：一键式的支付、充值、融资等综合金融服务</p></li><li><p>客户接触点、客户体验、维护客户关系</p></li><li><p>行业的秩序和格局的重定义</p></li></ol><h2 id="市场结构">市场结构</h2><p>结构可以分为4种类型</p><ol type="1"><li><p>完全竞争</p></li><li><p>垄断竞争</p></li><li><p>寡头垄断</p></li><li><p>完全垄断</p></li></ol><h2 id="商业模式">商业模式</h2><p><strong>定义：创造和传递客户价值的方式</strong></p><p><strong>价值链：创造和传递客户价值的过程流程</strong></p><h3 id="商业模式的创新">商业模式的创新</h3><h4 id="模仿">模仿</h4><ul><li>很多商业的产生都是模仿，模仿难易：制度 &gt; 产品 &gt; 战略 &gt;商业模式</li></ul><h4 id="回归价值目标">回归价值目标</h4><ul><li>集中市场占有率</li><li>集中资源</li><li>集中管理效能</li></ul><h4 id="分析工具创新板">分析工具：创新板</h4><center><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915204406290.png" alt="image-20230915204406290" style="zoom:33%;" /><br> 商业模式的创新板</center><h4 id="案例-itune的创新板">案例: itune的创新板</h4><center><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/202309152045519.png" alt="ipod的商业模式" style="zoom:50%;" /><br> ipod/itunes的创新板</center>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金融</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商业创新与金融战略-课程介绍</title>
    <link href="/2023/09/15/business-innovation-intro/"/>
    <url>/2023/09/15/business-innovation-intro/</url>
    
    <content type="html"><![CDATA[<h2 id="pre">Pre</h2><p><strong>思考：3年在100年中的意义？</strong></p><h3 id="专业主义">专业主义</h3><ul><li><p>目标：系统化的知识，属于自己独立思维的专业逻辑</p></li><li><p>手段：系统地阅读</p></li></ul><h3 id="理财课程目标">理财(课程目标)</h3><ul><li>需要体系的金融知识</li><li>了解真实的商业环境</li></ul><h2 id="课程安排">课程安排</h2><p>重点关注一个金融企业组织的不同时期的商业创新和战略选择问题</p><h3 id="内容大纲">内容大纲</h3><p>十二个主题:</p><ol type="1"><li>金融战略框架和商业环境</li><li>国民经济和金融体系</li><li>企业能力和信用评级</li><li>商业银行的业务战略与转型</li><li>投资银行（券商）的竞争策略</li><li>保险公司的多元化与专业化</li><li>私募基金公司的合作战略</li><li>金融互联网与互联网金融的国际化战略</li><li>金融工具与项目融资的匹配</li><li>企业成长策略：IPO和二级市场策略</li><li>金融类大型企业战略：母子公司管控</li><li>金融产业政策与管控</li></ol><p>另外，十个金融回归实业的案例、部分前沿文献</p><h3 id="考核">考核</h3><ul><li>案例分析</li><li>个人大作业，对于session的探讨</li></ul><h2 id="reference">Reference</h2><ol type="1"><li>《专业主义》大前研一</li></ol>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金融</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统与虚拟化安全-课程介绍</title>
    <link href="/2023/09/15/OS-Virtualization-Security-intro/"/>
    <url>/2023/09/15/OS-Virtualization-Security-intro/</url>
    
    <content type="html"><![CDATA[<h2 id="背景介绍">背景介绍</h2><h3 id="os的主流结构">OS的主流结构</h3><h4 id="微内核">微内核</h4><ul><li><p>定义：仅仅将os的核心功能（IPC通信、地址空间分配和基本的调度）加入内核，其余以用户态的进程方式提供服务的形式。（C-S）</p></li><li><p>优点</p><ul><li><p>面向对象原则，低耦合</p></li><li><p>支持分布式系统</p></li><li><p>可伸缩性好</p></li><li><p>可移植性好：与机器相关的代码隔离在很少部分的代码</p><center><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915111415794.png" alt="image-20230915111415794" style="zoom:50%;" /><br> 微内核的特点</p></center></li></ul></li><li><p>缺点</p></li></ul><h4 id="宏内核">宏内核</h4><ul><li>定义：将os的功能都放在内核态</li><li>优点<ul><li>实现简单</li><li>执行效率高</li></ul></li><li>缺点<ul><li>耦合度高</li><li>单点故障</li></ul></li></ul><h4 id="混合内核">混合内核</h4><ul><li>简单的思路：混合内核中会将一些原本微内核中运行在用户层的功能模块放回内核中，而不常用的，或者需要的时间很长的功能模块还是放在用户层</li></ul><h3 id="虚拟化技术">虚拟化技术</h3><ul><li><p>背景</p><ul><li><p>传统烟囱式的资源配置方式</p><center><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915111530927.png" alt="image-20230915111530927" style="zoom:50%;" /><br> 烟囱式的资源配置方式示意图</p></center></li><li><p>应用部署的周期长</p></li><li><p>服务器利用率的低下</p></li></ul></li><li><p>定义</p><ul><li>虚拟化是表示计算机资源的抽象方法，通过虚拟化可以用与访问抽象前资源一致的方法访问抽象后的资源<center><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915111547979.png" alt="image-20230915111547979" style="zoom:50%;" /><br> 理解虚拟计算模式</center></li></ul></li><li><p>常见的虚拟化软件、相关技术</p><ul><li>vmware<ul><li>vmware workstation：有一层host os，运行在host os上</li><li>ESX-sever：直接运行在硬件上</li></ul></li><li>Xen</li></ul></li></ul><h2 id="课程安排">课程安排</h2><blockquote><p>了解了linux内核、虚拟化技术的基础上，对其中的安全机制进行原理学习与实践</p></blockquote><h3 id="知识大纲">知识大纲</h3><ol type="1"><li>预备知识（linux、虚拟化）</li><li>安全概念与标准</li><li>安全机制</li><li>安全模型</li><li>安全体系架构</li><li>安全开发方法</li><li>os安全增强</li><li>虚拟化安全增强</li></ol><h3 id="实践安排">实践安排</h3><p>基于os或者虚拟化的安全开发实践，推荐选题如下：</p><center><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915111604479.png" alt="image-20230915111604479" style="zoom:33%;" /><br> 推荐的选题</center><!-- 参考内容 --><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://www.coursera.org/learn/os-virtsecurity#testimonials">Coursea课程</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>《Linux内核设计的艺术：图解操作系统架构设计与实现原理》<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Virtualization</tag>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
