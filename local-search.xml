<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多线程编程</title>
    <link href="/2023/09/17/multi-thread/"/>
    <url>/2023/09/17/multi-thread/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识概念"><strong>基础知识概念</strong></h2><h3 id="进程线程"><strong>进程+线程</strong></h3><p>简单理解： - 进程（process）：任务 - 线程（thread）：子任务</p><p>对比性能： - 创建进程比创建线程开销大 -进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快 -多进程稳定性比多线程高</p><h3 id="多任务程序的模式"><strong>多任务程序的模式</strong></h3><h4id="多进程模式每个进程只有一个线程"><strong>多进程模式（每个进程只有一个线程）</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090339727.png" alt="多进程模式" style="zoom:50%;" /></p><h4id="多线程模式每个进程有多个线程"><strong>多线程模式（每个进程有多个线程）</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090406298.png" alt="多线程模式" style="zoom:50%;" /></p><h4 id="多进程多线程模式"><strong>多进程＋多线程模式</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090426325.png" alt="多进程线程模式" style="zoom:50%;" /></p><h2 id="java多线程编程基础"><strong>java多线程编程基础</strong></h2><h3 id="创建线程"><strong>创建线程</strong></h3><blockquote><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行main()方法。在main()方法中，又可以启动其他线程</p></blockquote><h4 id="步骤"><strong>步骤</strong></h4><ol type="1"><li>实例化一个Thread对象，其run需要定义：<ul><li>方式1：自定义MyThread继承Thread,覆写run</li><li>方式2：创建Thread实例时，传入一个Runnable实例</li><li>方式3：lambda语法</li></ul></li><li>调用对象start方法，而不是run（不会产生新的线程）</li></ol><h4 id="例子"><strong>例子</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式1：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式2：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式3：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>        &#125;);<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程的优先级"><strong>线程的优先级</strong></h4><ul><li>操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行</li><li><code>Thread.setPriority(int n) // 1~10, 增大默认值5</code></li></ul><h3 id="线程的状态"><strong>线程的状态</strong></h3><h4 id="状态类型"><strong>状态类型</strong></h4><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行run()方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；</li><li>Terminated：线程已终止，因为run()方法执行完毕。</li></ul><h4 id="状态间的转移"><strong>状态间的转移</strong></h4><ul><li>不建议使用stop（）函数进行强制的结束</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090458683.png" alt="线程状态转移" style="zoom:50%;" /></p><h3 id="不同线程的交互"><strong>不同线程的交互</strong></h3><h4id="join等待某个线程结束后再执行"><strong>1、join：等待某个线程结束后再执行</strong></h4><blockquote><p>void join() Waits for this thread to die. void join(long millis)Waits at most millis milliseconds for this thread to die. void join(longmillis, int nanos) Waits at most millis milliseconds plus nanosnanoseconds for this thread to die.</p></blockquote><ul><li>一个线程还可以等待另一个线程直到其运行结束。</li><li>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</li><li>例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;[BThread] Thread&quot;</span>);<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(threadName + <span class="hljs-string">&quot; start.&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(threadName + <span class="hljs-string">&quot; loop at &quot;</span> + i);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>            System.out.println(threadName + <span class="hljs-string">&quot; end.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception from &quot;</span> + threadName + <span class="hljs-string">&quot;.run&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    BThread bt;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AThread</span><span class="hljs-params">(BThread bt)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;[AThread] Thread&quot;</span>);<br>        <span class="hljs-built_in">this</span>.bt = bt;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(threadName + <span class="hljs-string">&quot; start.&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            bt.join();<br>            System.out.println(threadName + <span class="hljs-string">&quot; end.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception from &quot;</span> + threadName + <span class="hljs-string">&quot;.run&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(threadName + <span class="hljs-string">&quot; start.&quot;</span>);<br>        <span class="hljs-type">BThread</span> <span class="hljs-variable">bt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BThread</span>();<br>        <span class="hljs-type">AThread</span> <span class="hljs-variable">at</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AThread</span>(bt);<br>        <span class="hljs-keyword">try</span> &#123;<br>            bt.start();<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            at.start();<br>            at.join();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception from main&quot;</span>);<br>        &#125;<br>        System.out.println(threadName + <span class="hljs-string">&quot; end!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中断线程"><strong>2、中断线程</strong></h4><h5 id="方式1interrupt"><strong>方式1：interrupt（）</strong></h5><blockquote><p>void interrupt() Interrupts this thread. static boolean interrupted()Tests whether the current thread has been interrupted.</p></blockquote><ul><li>在其他线程中对目标线程调用interrupt()方法</li><li>目标线程需要<mark>反复检测</mark>自身状态是否是interrupted状态，如果是，就立刻结束运行</li><li>interrupt()方法仅仅向t线程发出了“中断请求”，至于响应要看t的具体实现</li><li>对于调用<code>join()</code>处于等待其他线程状态的某线程，如果突然自己被<code>interrupt（）</code>中断，<code>join()</code>会弹出<code>InterruptedException</code>，所以要及时处理，并停下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        t.interrupt(); <span class="hljs-comment">// 中断t线程</span><br>        t.join(); <span class="hljs-comment">// 等待t线程结束</span><br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloThread</span>();<br>        hello.start(); <span class="hljs-comment">// 启动hello线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            hello.join(); <span class="hljs-comment">// 等待hello线程结束</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;interrupted!&quot;</span>);<br>        &#125;<br>        hello.interrupt();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!isInterrupted()) &#123;<br>            n++;<br>            System.out.println(n + <span class="hljs-string">&quot; hello!&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方式2runningfalse"><strong>方式2：running=false</strong></h5><p>注意点： - 线程中要用 <strong>volatile</strong>标记<code>boolean running</code>，因为这是一个线程间共享的变量，原因如下：-在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。- 如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存 -volatile关键字的目的是告诉虚拟机： -每次访问变量时，总是获取主内存的最新值； -每次修改变量后，立刻回写到主内存。 -volatile关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够<strong>立刻看到</strong> 修改后的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">HelloThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloThread</span>();<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1</span>);<br>        t.running = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标志位置为false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (running) &#123;<br>            n ++;<br>            System.out.println(n + <span class="hljs-string">&quot; hello!&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="守护线程daemon-thread"><strong>3、守护线程（DaemonThread）</strong></h4><blockquote><p>void setDaemon(boolean on) Marks this thread as either a daemonthread or a user thread. The Java Virtual Machine exits when the onlythreads running are all daemon threads. This method must be invokedbefore the thread is started.</p></blockquote><ul><li>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束</li><li>但是有些线程本身就是不会结束的，例如：Java垃圾回收线程就是一个典型的守护线程</li><li>守护线程是为其他线程服务的线程；</li><li>所有非守护线程都执行完毕后，虚拟机退出,即不等待守护线程</li><li>守护线程不能持有需要关闭的资源（如打开文件等）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>t.setDaemon(<span class="hljs-literal">true</span>);<br>t.start();<br></code></pre></td></tr></table></figure><h4 id="线程同步"><strong>4、线程同步</strong></h4><blockquote><p>多线程要解决一个重要问题：数据的一致性</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090748824.png" alt="加锁原理" style="zoom:50%;" /></p><ul><li>这种加锁和解锁之间的代码块我们称之为临界区（Critical Section）</li><li>效果：任何时候临界区最多只有一个线程能执行</li><li>步骤：如何使用synchronized：<ul><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用synchronized(lockObject) { ... }。</li></ul></li><li>注意：<ul><li>加锁、解锁会降低程序效率，所以仅在有数据一致性差异的地方加锁，可以并发的部分不用加</li><li>在使用synchronized的时候，不必担心抛出异常。因为无论是否有异常，都会在synchronized结束处正确释放锁</li><li><ahref="https://xie.infoq.cn/article/2b331b488a9bf5db8b6c59f5f">volatile和synchronized的区别</a>:概括就是volatile可以实现可见性，<mark>但是无法实现原子性</mark>，syn都可以。</li><li><ahref="https://www.cnblogs.com/54chensongxia/p/11910681.html">java原子性介绍</a>：自带原子性的操作不需要用synchronized</li></ul></li></ul><h5 id="synchronized例子"><strong>synchronized例子</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddThread</span>();<br>        <span class="hljs-type">var</span> <span class="hljs-variable">dec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecThread</span>();<br>        add.start();<br>        dec.start();<br>        add.join();<br>        dec.join();<br>        System.out.println(Counter.count);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock) &#123;<br>                Counter.count += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock) &#123;<br>                Counter.count -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程安全的类"><strong>5、线程安全的类</strong></h4><blockquote><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）</p></blockquote><h5 id="定义一个线程安全的类"><strong>定义一个线程安全的类</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            count += n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            count -= n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">var</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Counter();<br><span class="hljs-type">var</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Counter();<br><br><span class="hljs-comment">// 对c1进行操作的线程:</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    c1.add();<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    c1.dec();<br>&#125;).start();<br><br><span class="hljs-comment">// 对c2进行操作的线程:</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    c2.add();<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    c2.dec();<br>&#125;).start();<br></code></pre></td></tr></table></figure><ul><li>这样一来，线程调用add()、dec()方法时，它不必关心同步逻辑，因为synchronized代码块在add()、dec()方法内部。</li><li>并且，我们注意到，synchronized <strong>锁住的对象是this</strong>，即当前实例，这又使得创建多个Counter实例的时候，它们<strong>之间互不影响</strong> ，可以并发执行</li></ul><h5 id="java中线程安全的类">java中线程安全的类</h5><ul><li>Java标准库的java.lang.StringBuffer</li><li>一些不变类，例如String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的</li><li>类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的</li></ul><blockquote><p>大部分类，例如ArrayList，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么ArrayList是可以安全地在线程间共享的。</p></blockquote><h5id="synchronized位置与修饰的目标"><strong>synchronized位置与修饰的目标</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 联系着看上面那个线程安全的类</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 当我们锁住的是this实例时，实际上可以用synchronized修饰这个方法。下面两种写法是等价的：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 锁住this</span><br>        count += n;<br>    &#125; <span class="hljs-comment">// 解锁</span><br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 锁住this</span><br>    count += n;<br>&#125; <span class="hljs-comment">// 解锁</span><br><br><span class="hljs-comment">// 如果static，则锁住的是Counter.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="死锁"><strong>6、死锁</strong></h4><h5 id="可重入锁"><strong>可重入锁</strong></h5><ul><li>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁</li><li>例如下面的例子，add里面调用dec，就是再次获取当前实例的this锁。</li><li><strong>原理</strong>：获取锁的时候，会判断是否是第一次获取，同时记录这是第几次获取。每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>            dec(-n);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count += n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        count += n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="死锁的例子"><strong>死锁的例子</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(lockA) &#123; <span class="hljs-comment">// 获得lockA的锁</span><br>        <span class="hljs-built_in">this</span>.value += m;<br>        <span class="hljs-keyword">synchronized</span>(lockB) &#123; <span class="hljs-comment">// 获得lockB的锁</span><br>            <span class="hljs-built_in">this</span>.another += m;<br>        &#125; <span class="hljs-comment">// 释放lockB的锁</span><br>    &#125; <span class="hljs-comment">// 释放lockA的锁</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(lockB) &#123; <span class="hljs-comment">// 获得lockB的锁</span><br>        <span class="hljs-built_in">this</span>.another -= m;<br>        <span class="hljs-keyword">synchronized</span>(lockA) &#123; <span class="hljs-comment">// 获得lockA的锁</span><br>            <span class="hljs-built_in">this</span>.value -= m;<br>        &#125; <span class="hljs-comment">// 释放lockA的锁</span><br>    &#125; <span class="hljs-comment">// 释放lockB的锁</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上面的代码中，add和dec可能会互相等待对方的锁</li><li>修改方式，将dec中的lockB和lockA交换</li></ul><h4 id="多线程协调方式"><strong>7、多线程协调方式</strong></h4><p>**synchronized + wait*</p><p><strong>Reentrantlock + Condition</strong></p><p><strong>ReadWriteLock、StampedLock</strong></p><p><strong>Semaphore</strong></p><p><strong>Concurrent集合</strong></p><p><strong>Atomic</strong></p><p><strong>线程池</strong></p><h4 id="future结果的返回"><strong>8、Future：结果的返回</strong></h4><h4id="forkjoin任务的拆解"><strong>9、Forkjoin：任务的拆解</strong></h4><h4 id="threadlocal-线程内的上下文"><strong>10、ThreadLocal:线程内的上下文</strong></h4><h2 id="场景案例"><strong>场景案例</strong></h2><h3id="一个线程等待多个并发的线程"><strong>1、一个线程等待多个并发的线程</strong></h3><h4 id="可选的方案"><strong>可选的方案</strong></h4><ul><li>使用 thread.join ()方法，让主线程等待子线程的终止。也就是说主线程的代码块中，如果碰到了t.join ()方法，此时主线程需要等待（阻塞），等待子线程结束了，才能继续执行 t.join() 之后的代码块。</li><li>使用 CountDownLatch类，这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为 0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li><li>使用 CyclicBarrier类，这个类使一组线程相互等待到达一个公共屏障点。在CyclicBarrier类的内部有一个计数器，每个线程在到达屏障点的时候都会调用await () 方法将自己阻塞，此时计数器会减 1，当计数器减为 0的时候所有因调用 await () 方法而被阻塞的线程将被唤醒。</li><li><ahref="https://zhuanlan.zhihu.com/p/139020914">区分CountDownLatch和CyclicBarrier</a>：一句话概括就是前者是1个线程等待多个线程结束再开始，后者是多个线程相互等待到齐了再并发开始</li></ul><h4 id="例子采取countdownlatch-join"><strong>例子：采取CountDownLatch +join</strong></h4><blockquote><p><ahref="https://docs.oracle.com/javase/8/docs/api/">CountDownLatch官方文档</a></p></blockquote><h5 id="场景描述"><strong>场景描述</strong></h5><ul><li>用于将DAG（如下图）的不同节点创建线程，并用DAG的边关系协调线程关系</li><li>有一个主线程，要在所有子线程开始前做一些准备工作</li><li>子线程之间的依赖关系可以建模为DAG图</li><li>子线程完成工作后，主线程做一些收尾工作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917090834238.png" alt="gBuilder场景案例" style="zoom: 33%;" /></p><h5 id="说明"><strong>说明</strong>：</h5><ul><li>CountDownLatch用于主线程</li><li>join用于给子线程做一个先后关系的（DAG的有向边）</li></ul><h5 id="代码片段"><strong>代码（片段）</strong></h5><p><strong>1、Scheduler（主线程）</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arrange</span><span class="hljs-params">(DAG dag)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ArrayList&lt;Node&gt; nodes = dag.getNodes();<br>        ArrayList&lt;Edge&gt; edges = dag.getEdges();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(nodes.size());<br>        <span class="hljs-comment">// 便于后面添加线程之间的先后关系</span><br>        ArrayList&lt;WorkerThread&gt; threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// node的id对应的Thread</span><br>        HashMap&lt;Integer,WorkerThread&gt; mit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nodes.size();i++)<br>        &#123;<br>            <span class="hljs-type">WorkerThread</span> <span class="hljs-variable">tp</span> <span class="hljs-operator">=</span> ThreadStore.createThread(startSignal,doneSignal,nodes.get(i));<br>            tp.start();<br>            <span class="hljs-comment">// 将id和thread映射</span><br>            mit.put(nodes.get(i).getId(),tp);<br>            threads.add(tp);<br>        &#125;<br>        <span class="hljs-comment">// 准备工作</span><br>        System.out.println(<span class="hljs-string">&quot;Preparing something for the process of DAG...&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 在这里把对应的Thread之间加一些关系</span><br>        <span class="hljs-keyword">for</span>(Edge edge:edges)<br>        &#123;<br>            <span class="hljs-comment">// 添加前置关系</span><br>            mit.get(edge.getTarget()).addFormer(mit.get(edge.getSource()));<br>        &#125;<br>        <span class="hljs-comment">// 所有没有前置的线程可以开始了</span><br>        startSignal.countDown();<br>        <span class="hljs-comment">// 等所有的线程都完成了</span><br>        doneSignal.await();<br>        <span class="hljs-comment">// 收尾工作</span><br>        System.out.println(<span class="hljs-string">&quot;Finish the whole DAG.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Scheduler</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scheduler</span>();<br>        <span class="hljs-comment">// ? Json2G的具体类型待定，此处简单模拟</span><br>        <span class="hljs-type">DAG</span> <span class="hljs-variable">dag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DAG</span>(Json2G.extractNodes(),Json2G.extractEdges());<br>        <span class="hljs-comment">// execute the DAG</span><br>        sc.arrange(dag);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><strong>2、WorkerThread（子线程）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch startSignal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node node;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;WorkerThread&gt; formers;<br>    WorkerThread(CountDownLatch startSignal,CountDownLatch doneSignal, Node node) &#123;<br>        <span class="hljs-built_in">this</span>.startSignal = startSignal;<br>        <span class="hljs-built_in">this</span>.doneSignal = doneSignal;<br>        <span class="hljs-built_in">this</span>.node = node;<br>        <span class="hljs-built_in">this</span>.formers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFormer</span><span class="hljs-params">(WorkerThread former)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.formers.add(former);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 运行对应的节点的函数</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            startSignal.await();<br>            <span class="hljs-comment">// 等待前面的进程完成先</span><br>            <span class="hljs-keyword">for</span>(Thread former:formers)<br>            &#123;<br>                former.join();<br>            &#125;<br>            <span class="hljs-comment">// 开始进行node的运行</span><br>            node.process();<br>            <span class="hljs-comment">// 锁减少1</span><br>            doneSignal.countDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p>[1] <ahref="https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185">java-廖雪峰</a></p><p>[2] <a href="http://t.csdn.cn/j0SeD">CSDN</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法复杂度优化的技巧</title>
    <link href="/2023/09/17/algorithm-complex-optim/"/>
    <url>/2023/09/17/algorithm-complex-optim/</url>
    
    <content type="html"><![CDATA[<h2 id="一移项法">一、移项法</h2><p>●原理：所谓的移项法，就是将<mark>目标等式</mark>进行左右等价变化，辅助以哈希表/桶，从而减少类似<code>for(j:for(i))</code>的双层循环</p><p>●效果： 将算法从 $ O(n^2) $ 复杂度降低为 $ O(n) $</p><h3 id="使数组和能被p整除"><ahref="https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/2158435/tao-lu-qian-zhui-he-ha-xi-biao-pythonjav-rzl0/">1590.使数组和能被P整除</a></h3><h4 id="前置余数知识">前置余数知识</h4><p>1、<code>( a + b ) % p = a % p + b % p</code></p><p>2、假如<code>( x - y) % p == 0</code> 1.假设<code>x &gt;= 0,y &gt;= 0</code>, 则有 <code>x % p == y % p</code>2.假设上面的某一方<code>x &lt; 0</code>，则有<code>x % p + p == y % p</code></p><h4 id="思路">思路</h4><p>1、利用余数结论，计算<strong>前缀和对p的余数</strong>，则<code>s[n]</code>就表示整体sum对p的余数。</p><p>2、则问题等价于找到 - 2.1、在前缀和数组上找到两个数<code>s[left]</code>和 <code>s[right]</code>，满足<code>right−left</code>最小且<code>(s[right]−s[left]) % p == s[n]</code>- 2.2、<mark>移项</mark>，<code>s[right]−s[n] % p == s[left]</code> -2.3、考虑可能出现正负<code>((s[right] − s[n]) % p + p) % p =  s[left]</code></p><p>3、<mark>避免双层遍历找left和right：</mark>使用一个哈希，存储<code>s[i]</code>出现的最近下标</p><p>4、遍历一遍，到了right，就找哈希里面是否存在left满足 =<code>((s[right] − s[n]) % p + p) % p</code></p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), ans = n, s[n + <span class="hljs-number">1</span>];<br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        s[i + <span class="hljs-number">1</span>] = (s[i] + nums[i]) % p;<br>    <span class="hljs-type">int</span> x = s[n];<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 移除空子数组（这行可以不要）</span><br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; last;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>    &#123;<br>        last[s[i]] = i;<br>        <span class="hljs-keyword">auto</span> it = last.<span class="hljs-built_in">find</span>((s[i] - x + p) % p);<br>        <span class="hljs-keyword">if</span> (it != last.<span class="hljs-built_in">end</span>())<br>            ans = <span class="hljs-built_in">min</span>(ans, i - it-&gt;second);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans &lt; n ? ans : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试题-17.05.-字母与数字"><ahref="https://leetcode.cn/problems/find-longest-subarray-lcci/description/">面试题17.05. 字母与数字</a></h3><h4 id="思路-1">思路</h4><p>1、前缀计数：<code>left1[i]</code>记录到i位置的字母个数，<code>left2[j]</code>记录到j位置的数字个数</p><p>2、思路1：暴力，$ O(n^2) $，看看什么位置满足<code>left1[j]-left1[i] ==  left2[j]-left2[i]</code>,找到最小的i</p><p>3、思路2：<mark>移项</mark>，$ O(n) $，即找到<code>left1[j]-left2[j] ==  left1[i]-left2[i]</code>，那么用<code>map</code>保存当前差值<code>(left1[i]-left2[i])</code>出现的最早位置</p><blockquote><p>当然这题对字母、数字建模为-1，1。可以压缩空间到O(n);且用桶代替map的时间效率更高。 这里重点介绍移项的思想</p></blockquote><h4 id="代码-1">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findLongestSubarray</span><span class="hljs-params">(vector&lt;string&gt; &amp;array)</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; uii;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left1</span><span class="hljs-params">(array.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left2</span><span class="hljs-params">(array.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    vector&lt;string&gt; ansv;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ansp = <span class="hljs-built_in">make_pair</span>(array.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, array.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((array[i][<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; array[i][<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || (array[i][<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; array[i][<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>))<br>        &#123;<br>            left1[i + <span class="hljs-number">1</span>] = left1[i] + <span class="hljs-number">1</span>;<br>            left2[i + <span class="hljs-number">1</span>] = left2[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            left1[i + <span class="hljs-number">1</span>] = left1[i];<br>            left2[i + <span class="hljs-number">1</span>] = left2[i] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= array.<span class="hljs-built_in">size</span>(); j++)<br>    &#123;<br>        <span class="hljs-type">int</span> tp = left1[j] - left2[j];<br>        <span class="hljs-keyword">if</span> (uii.<span class="hljs-built_in">find</span>(tp) != uii.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j - uii[tp] + <span class="hljs-number">1</span> &gt; ans)<br>            &#123;<br>                ansp.first = uii[tp];<br>                ansp.second = j;<br>                ans = <span class="hljs-built_in">max</span>(ans, j - uii[tp] + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j - uii[tp] + <span class="hljs-number">1</span> == ans &amp;&amp; uii[tp] &lt; ansp.first)<br>            &#123;<br>                ansp.first = uii[tp];<br>                ansp.second = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            uii[tp] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ansp.first == array.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ansv;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ansp.first; i &lt; ansp.second; i++)<br>    &#123;<br>        ansv.<span class="hljs-built_in">push_back</span>(array[i]);<br>        cout &lt;&lt; array[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ansv;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计中位数为-k-的子数组"><ahref="https://leetcode.cn/problems/count-subarrays-with-median-k/description/">2488.统计中位数为 K 的子数组</a></h3><h4 id="思路1">思路1</h4><p>0、找到k所在的位置kInd</p><p>1、写出<mark>目标表达式：</mark>: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对于奇数长度的子序列：</span><br>「左侧小于 + 右侧小于 = 左侧大于 + 右侧大于」<br><span class="hljs-comment">//等价于</span><br>「左侧小于 - 左侧大于 = 右侧大于 - 右侧小于」<br><br><span class="hljs-comment">// 对于偶数长度的子序列：</span><br>「左侧小于 + 右侧小于 + <span class="hljs-number">1</span> = 左侧大于 + 右侧大于」<br><span class="hljs-comment">//等价于</span><br>「左侧小于 - 左侧大于 = 右侧大于 - 右侧小于 - <span class="hljs-number">1</span>」<br><br></code></pre></td></tr></table></figure>2、统计kInd左右侧，每个位置到kInd这段子数组中，小于、大于K值的位置数，分别记为smallK、bigK；</p><p>3、用一个哈希记录左侧每个位置的smallK -bigK位置数、右侧bigK-smallK的位置数，然后同时开第2个维度，记录位置的距离kInd的奇、偶。</p><p>4、之后根据不同位置距离kInd的奇数、偶数，可以得到子序列的奇偶，也就可以使用步骤1中的目标表达式，具体见下面代码</p><h4 id="思路2"><mark>思路2：</mark></h4><p>参考：灵神的神级建模，见<ahref="https://leetcode.cn/problems/count-subarrays-with-median-k/solutions/1993439/deng-jie-zhuan-huan-pythonjavacgo-by-end-5w11/">原题解</a></p><h4 id="代码-2">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// （思路1）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> kInd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> bigK;<br>    <span class="hljs-type">int</span> smallK;<br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; leftH;<br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; rightH;<br><br>    set&lt;<span class="hljs-type">int</span>&gt; hasPos;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">if</span> (nums[i] == k)<br>            kInd = i;<br>    <span class="hljs-type">int</span> i = kInd - <span class="hljs-number">1</span>, j = kInd + <span class="hljs-number">1</span>;<br><br>    leftH[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    rightH[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    smallK = <span class="hljs-number">0</span>;<br>    bigK = <span class="hljs-number">0</span>;<br>    hasPos.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 统计</span><br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; k)<br>        &#123;<br>            smallK++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            bigK++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftH.<span class="hljs-built_in">find</span>(smallK - bigK) == leftH.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tp = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            tp[(kInd - i) % <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            leftH[smallK - bigK] = tp;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            leftH[smallK - bigK][(kInd - i) % <span class="hljs-number">2</span>]++;<br>        &#125;<br>        i--;<br>    &#125;<br>    smallK = <span class="hljs-number">0</span>;<br>    bigK = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (j &lt; nums.<span class="hljs-built_in">size</span>())<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (nums[j] &lt; k)<br>        &#123;<br>            smallK++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            bigK++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (rightH.<span class="hljs-built_in">find</span>(bigK - smallK) == rightH.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tp = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            tp[(j - kInd) % <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            rightH[bigK - smallK] = tp;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            rightH[bigK - smallK][(j - kInd) % <span class="hljs-number">2</span>]++;<br>        &#125;<br>        hasPos.<span class="hljs-built_in">insert</span>(bigK - smallK);<br>        j++;<br>    &#125;<br><br>    <span class="hljs-comment">// hash统计位置数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos : hasPos)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (leftH.<span class="hljs-built_in">find</span>(pos) != leftH.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> rOu = rightH[pos][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> lOu = leftH[pos][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> rJi = rightH[pos][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> lJi = leftH[pos][<span class="hljs-number">1</span>];<br>            ans += rOu * lOu;<br>            ans += rJi * lJi;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftH.<span class="hljs-built_in">find</span>(pos - <span class="hljs-number">1</span>) != leftH.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            ans += rightH[pos][<span class="hljs-number">0</span>] * leftH[pos - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            ans += rightH[pos][<span class="hljs-number">1</span>] * leftH[pos - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二剪枝">二、剪枝</h2><p>●原理：广义的剪枝法，就是将没有必要的搜索空间直接跳过，常见于递归问题。但要建立一个剪枝的思想，在各类问题中都适用，<mark>不局限于递归、搜索树。</mark></p><p>●效果： 将算法进行不同程度优化</p><h3 id="最大网络秩"><ahref="https://leetcode.cn/problems/maximal-network-rank/description/">1615.最大网络秩</a></h3><p>参考(关注思路2的分类讨论)：<ahref="https://leetcode.cn/problems/maximal-network-rank/solutions/2167846/zui-da-wang-luo-zhi-by-leetcode-solution-x4gx/">leetcode官方题解</a></p>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旧博客打包部署流程</title>
    <link href="/2023/09/17/old-blog-package-deploy/"/>
    <url>/2023/09/17/old-blog-package-deploy/</url>
    
    <content type="html"><![CDATA[<h2 id="al小站博客简介">“AL小站”博客简介</h2><ul><li>这是一个前后端<strong>不分离</strong>的web项目 , 已失效的链接 <ahref="http://www.yuguang.zone">AL's Blog</a></li><li>前端：semantic-ui组件库，thymeleaf模板引擎</li><li>后端：springboot、mybatis-plus</li></ul><h2 id="前置条件">0、前置条件</h2><ul><li><p>有一台云服务器</p></li><li><p>云服务器上面安全组配置，要打开一些端口号（http、mysql等等对应的不同端口），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917084808737.png" alt="安全组配置" style="zoom:33%;" /></p></li></ul><h2 id="打包步骤">1、打包步骤</h2><h3 id="移除springboot内嵌的tomcat">1.1 移除springboot内嵌的tomcat</h3><p><strong>修改pom.xml文件</strong> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 移除原本自带的tomcat --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 添加servle依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure> ### 1.2 设置打包的方式依旧是<strong>pom.xml文件</strong>，设置打包导出<code>war</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aidan<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>albog-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>albog-server<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h3 id="启动类继承springbootservletinitializer">1.3启动类继承SpringBootServletInitializer</h3><p><strong>修改后</strong>的启动类代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.aidan.alblogserver.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlblogServerApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootServletInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title function_">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.configure(builder);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(AlblogServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="打包成war">1.4 打包成war</h3><p>idea里面依次点击<code>clean</code>-<code>package</code>，如下图："idea中的按钮"</p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917085129130.png" alt="idea操作位置" style="zoom:33%;" /></p><p>工程文件夹下的<strong>target</strong>里面生成了对应的war包。</p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917085217315.png" alt="war包位置" style="zoom:33%;" /></p><p><strong>至此，完成了打包过程。</strong></p><h2 id="服务器环境配置">2、服务器环境配置</h2><ul><li>目标服务器环境（Centos7）</li><li>在<code>war</code>传到服务器之前，先准备好环境，包括以下内容：</li><li>mysql</li><li>jdk</li><li>tomcat</li></ul><h3 id="安装mysql">2.1 安装MySQL</h3><p>卸载Centos7自带mariadb <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找</span><br>rpm -qa|grep mariadb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">mariadb-libs-5.5.52-1.el7.x86_64</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载</span><br>rpm -e mariadb-libs-5.5.52-1.el7.x86_64 --nodeps<br></code></pre></td></tr></table></figure> 解压mysql <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建mysql安装包存放点</span><br>mkdir /usr/server/mysql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar xvf mysql-5.7.34-1.el7.x86_64.rpm-bundle.tar<br></code></pre></td></tr></table></figure> 执行安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到安装目录</span><br>cd /usr/server/mysql/<br>yum -y install libaio<br>yum -y install libncurses*<br>yum -y install perl perl-devel<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>rpm -ivh mysql-community-common-5.7.34-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-libs-5.7.34-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-client-5.7.34-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-server-5.7.34-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure></p><p>修改密码 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动mysql</span><br>systemctl start mysqld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看生成的临时root密码</span><br>cat /var/log/mysqld.log | grep password<br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录mysql</span><br>mysql -u root -p<br>Enter password: #输入在日志中生成的临时密码<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新root密码 设置为root</span><br>set global validate_password_policy=0;<br>set global validate_password_length=1;<br>set password=password(&#x27;root&#x27;);<br></code></pre></td></tr></table></figure> 授予远程连接权限 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;root&#x27;;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新</span><br>flush privileges;<br><br></code></pre></td></tr></table></figure> 控制命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">mysql的启动和关闭 状态查看</span><br>systemctl stop mysqld<br>systemctl status mysqld<br>systemctl start mysqld<br><span class="hljs-meta prompt_">#</span><span class="language-bash">建议设置为开机自启动服务</span><br>systemctl enable mysqld<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看是否已经设置自启动成功</span><br>systemctl list-unit-files | grep mysqld<br></code></pre></td></tr></table></figure> 关闭防火墙 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --state #查看防火墙状态<br>systemctl stop firewalld.service #停止firewall<br>systemctl disable firewalld.service #禁止firewall开机启动<br></code></pre></td></tr></table></figure></p><h3 id="配置jdk">2.2 配置JDK</h3><p>下载JDK，登录官方https://www.oracle.com/java/technologies/downloads/#java8下载所需版本的JDK，版本为JDK 1.8,如图：</p><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230917085258251.png" alt="jdk下载包" style="zoom:33%;" /></p><p>解压 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zvxf jdk-8u131-linux-x64.tar.gz<br></code></pre></td></tr></table></figure> 编辑 /etc/profile 文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件末尾增加</span><br>export JAVA_HOME=/usr/server/jdk1.8.0_131<br>export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH<br></code></pre></td></tr></table></figure>执行source命令，使配置立即生效 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure> 检查是否安装成功<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure></p><h3 id="安装tomcat">2.3 安装tomcat</h3><p>官网地址：https://tomcat.apache.org/将下载的<strong>apache-tomcat-8.5.86.tar.gz</strong>安装包放在服务器的<code>/usr/home/download</code>目录，并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入/usr/local/download目录</span><br>cd /usr/local/download<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压Tomcat压缩包</span><br>tar -zxvf apache-tomcat-8.5.86.tar.gz<br></code></pre></td></tr></table></figure><p>进入Tomcat的bin目录，启动Tomcat <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入Tomcat的bin目录，启动Tomcat</span><br>cd apache-tomcat-8.5.86/bin/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动Tomcat</span><br>./startup.sh<br></code></pre></td></tr></table></figure>使用浏览器访问Tomcat，地址Linux的ip:8080，若成功可以看到tomcat的欢迎页面，之后在war上传前先关闭tomcat：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">暂时先关闭Tomcat</span><br>./shutdown.sh<br></code></pre></td></tr></table></figure> 配置tomcat环境变量 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br></code></pre></td></tr></table></figure> 最后几行现在变成这样<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export CATALINA_BASE=/home/download/apache-tomcat-8.5.86<br>export CATALINA_HOME=/home/download/apache-tomcat-8.5.86<br>export JAVA_HOME=/usr/server/jdk8/jdk1.8.0_192<br>export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH<br></code></pre></td></tr></table></figure> <strong>记得再source一下配置文件！</strong></p><h2 id="部署过程">3、部署过程</h2><p><strong>注意：当前tomcat处于关闭状态</strong></p><h3 id="删除原本tomcat文件夹下的root目录">3.1删除原本tomcat文件夹下的ROOT目录</h3><p>进入tomcat的webapps文件夹，删除其下ROOT文件夹 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd apache-tomcat-8.5.86/webapps<br>rm -rf ROOT<br></code></pre></td></tr></table></figure></p><h3 id="上传war包到webapps文件夹">3.2 上传war包到webapps文件夹</h3><p>将war上传到webapps文件夹，<strong>修改war名为<code>ROOT.war</code></strong>。启动tomcat： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入Tomcat的bin目录，启动Tomcat</span><br>cd apache-tomcat-8.5.86/bin/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动Tomcat</span><br>./startup.sh<br></code></pre></td></tr></table></figure>此时，会自动解压该war包，生成一个新的ROOT文件夹。<strong>至此，终于完成部署</strong>！通过IP:端口号可以访问博客服务</p><h2 id="tomcat的端口设置">4、tomcat的端口设置</h2><blockquote><p>由于最终是想通过域名进行访问，而不是ip:端口方式，因此后续会进行域名的解析，但是解析无法到解析端口，用户访问域名时会默认访问80端口</p></blockquote><ul><li>方案1：ngnix进行端口转发（略）</li><li>方案2：设置项目的port为80，修改tomcat默认端口由于博主很懒，采用了方案2，步骤如下：</li></ul><h3 id="修改项目application.yml">4.1 修改项目application.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="修改tomcat的配置">4.2 修改tomcat的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">假设已经在tomcat目录，进入tomcat的conf目录</span><br>cd conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑server.xml</span><br>vi server.xml<br></code></pre></td></tr></table></figure><p>将如下几行8080修改为80 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">executor</span>=<span class="hljs-string">&quot;tomcatThreadPool&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>关闭再重启tomcat服务，<strong>完成！</strong></p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微电子前沿技术-Lesson1</title>
    <link href="/2023/09/16/microelectronic-cutting-edge-leeson1/"/>
    <url>/2023/09/16/microelectronic-cutting-edge-leeson1/</url>
    
    <content type="html"><![CDATA[<h2 id="半导体器件">半导体器件</h2><h3 id="分类按产品">分类（按产品）</h3><ul><li>集成电路（比例：市场份额）<ul><li><strong>模拟芯片</strong>（15%）</li><li>数字芯片（85%）</li></ul></li><li>光电子</li><li>传感器</li><li>分立的器件</li></ul><h4 id="国内芯片设计公司产品领域分布">国内芯片设计公司产品领域分布</h4><ul><li>高点：消费类、通信</li><li>增长点：多媒体、计算机芯片</li><li>模拟芯片占比国内12.8%</li></ul><h3 id="模拟芯片">模拟芯片</h3><blockquote><p>*：市场份额最大的</p></blockquote><ul><li>信号链<ul><li>ADC、DAC</li><li>放大器、比较器（*）</li><li>接口芯片</li></ul></li><li>电源链（*）</li><li>射频前端</li></ul><h4 id="电源管理">电源管理</h4><h5 id="功能">功能</h5><ul><li>负责在电子设备系统中对电能进行变换、分配、检测以及其他电能指责的芯片</li><li>将源电压、电流转化为可被微处理器、传感器等负载使用的电源</li></ul><h5 id="分类">分类</h5><ul><li>开关电源（DC/DC，AC/DC）<ul><li>电荷泵-手机快充相关</li></ul></li><li>线性电源<ul><li><ahref="https://zhuanlan.zhihu.com/p/36101543">参考和开关电源的区别</a></li></ul></li><li>电池管理<ul><li>充电管理：手机最佳充电范围 (20%,80%）</li><li>电池保护：和电池管理芯片协同起作用</li></ul></li><li>电源开关<ul><li>负载开关：置于电池、电源和负载之间，只有在系统需要负载时才打开，从而最大限度地减少电力消耗</li><li>低侧开关、高侧开关：相对于外部负载，将半导体<em>开关</em>配置在上侧电路的叫作高边，配置在下侧电路叫作低边</li></ul></li><li>LED驱动</li><li>MOS驱动<ul><li>多应用于工业类的汽车等器件，控制电压率、速度</li></ul></li><li>电机驱动</li></ul><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/36101543<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微电子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商业创新与金融战略-Lesson1</title>
    <link href="/2023/09/15/business-innovation-lesson1/"/>
    <url>/2023/09/15/business-innovation-lesson1/</url>
    
    <content type="html"><![CDATA[<h2 id="新一代的金融业格局">新一代的金融业格局</h2><p>围绕霸权的三大斗争</p><ol type="1"><li><p>科技公司和金融机构：一键式的支付、充值、融资等综合金融服务</p></li><li><p>客户接触点、客户体验、维护客户关系</p></li><li><p>行业的秩序和格局的重定义</p></li></ol><h2 id="市场结构">市场结构</h2><p>结构可以分为4种类型</p><ol type="1"><li><p>完全竞争</p></li><li><p>垄断竞争</p></li><li><p>寡头垄断</p></li><li><p>完全垄断</p></li></ol><h2 id="商业模式">商业模式</h2><p><strong>定义：创造和传递客户价值的方式</strong></p><p><strong>价值链：创造和传递客户价值的过程流程</strong></p><h3 id="商业模式的创新">商业模式的创新</h3><h4 id="模仿">模仿</h4><ul><li>很多商业的产生都是模仿，模仿难易：制度 &gt; 产品 &gt; 战略 &gt;商业模式</li></ul><h4 id="回归价值目标">回归价值目标</h4><ul><li>集中市场占有率</li><li>集中资源</li><li>集中管理效能</li></ul><h4 id="分析工具创新板">分析工具：创新板</h4><center><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915204406290.png" alt="image-20230915204406290" style="zoom:33%;" /><br> 商业模式的创新板</center><h4 id="案例-itune的创新板">案例: itune的创新板</h4><center><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/202309152045519.png" alt="ipod的商业模式" style="zoom:50%;" /><br> ipod/itunes的创新板</center>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金融</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商业创新与金融战略-课程介绍</title>
    <link href="/2023/09/15/business-innovation-intro/"/>
    <url>/2023/09/15/business-innovation-intro/</url>
    
    <content type="html"><![CDATA[<h2 id="pre">Pre</h2><p><strong>思考：3年在100年中的意义？</strong></p><h3 id="专业主义">专业主义</h3><ul><li><p>目标：系统化的知识，属于自己独立思维的专业逻辑</p></li><li><p>手段：系统地阅读</p></li></ul><h3 id="理财课程目标">理财(课程目标)</h3><ul><li>需要体系的金融知识</li><li>了解真实的商业环境</li></ul><h2 id="课程安排">课程安排</h2><p>重点关注一个金融企业组织的不同时期的商业创新和战略选择问题</p><h3 id="内容大纲">内容大纲</h3><p>十二个主题:</p><ol type="1"><li>金融战略框架和商业环境</li><li>国民经济和金融体系</li><li>企业能力和信用评级</li><li>商业银行的业务战略与转型</li><li>投资银行（券商）的竞争策略</li><li>保险公司的多元化与专业化</li><li>私募基金公司的合作战略</li><li>金融互联网与互联网金融的国际化战略</li><li>金融工具与项目融资的匹配</li><li>企业成长策略：IPO和二级市场策略</li><li>金融类大型企业战略：母子公司管控</li><li>金融产业政策与管控</li></ol><p>另外，十个金融回归实业的案例、部分前沿文献</p><h3 id="考核">考核</h3><ul><li>案例分析</li><li>个人大作业，对于session的探讨</li></ul><h2 id="reference">Reference</h2><ol type="1"><li>《专业主义》大前研一</li></ol>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金融</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统与虚拟化安全-课程介绍</title>
    <link href="/2023/09/15/OS-Virtualization-Security-intro/"/>
    <url>/2023/09/15/OS-Virtualization-Security-intro/</url>
    
    <content type="html"><![CDATA[<h2 id="背景介绍">背景介绍</h2><h3 id="os的主流结构">OS的主流结构</h3><h4 id="微内核">微内核</h4><ul><li><p>定义：仅仅将os的核心功能（IPC通信、地址空间分配和基本的调度）加入内核，其余以用户态的进程方式提供服务的形式。（C-S）</p></li><li><p>优点</p><ul><li><p>面向对象原则，低耦合</p></li><li><p>支持分布式系统</p></li><li><p>可伸缩性好</p></li><li><p>可移植性好：与机器相关的代码隔离在很少部分的代码</p><center><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915111415794.png" alt="image-20230915111415794" style="zoom:50%;" /><br> 微内核的特点</p></center></li></ul></li><li><p>缺点</p></li></ul><h4 id="宏内核">宏内核</h4><ul><li>定义：将os的功能都放在内核态</li><li>优点<ul><li>实现简单</li><li>执行效率高</li></ul></li><li>缺点<ul><li>耦合度高</li><li>单点故障</li></ul></li></ul><h4 id="混合内核">混合内核</h4><ul><li>简单的思路：混合内核中会将一些原本微内核中运行在用户层的功能模块放回内核中，而不常用的，或者需要的时间很长的功能模块还是放在用户层</li></ul><h3 id="虚拟化技术">虚拟化技术</h3><ul><li><p>背景</p><ul><li><p>传统烟囱式的资源配置方式</p><center><p><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915111530927.png" alt="image-20230915111530927" style="zoom:50%;" /><br> 烟囱式的资源配置方式示意图</p></center></li><li><p>应用部署的周期长</p></li><li><p>服务器利用率的低下</p></li></ul></li><li><p>定义</p><ul><li>虚拟化是表示计算机资源的抽象方法，通过虚拟化可以用与访问抽象前资源一致的方法访问抽象后的资源<center><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915111547979.png" alt="image-20230915111547979" style="zoom:50%;" /><br> 理解虚拟计算模式</center></li></ul></li><li><p>分类</p><ul><li>网络虚拟化：网络的硬件与软件资源整合，向用户提供虚拟网络连接的虚拟化技术</li><li>存储虚拟化：物理的存储设备提供一个抽象的逻辑视图</li><li>系统虚拟化：一台物理机上虚拟出一台或多台虚拟机(VM)</li></ul></li><li><p>常见的虚拟化软件、相关技术</p><ul><li>vmware<ul><li>vmware workstation：有一层host os，运行在host os上</li><li>ESX-sever：直接运行在硬件上</li></ul></li><li>Xen</li></ul></li></ul><h2 id="课程安排">课程安排</h2><blockquote><p>了解了linux内核、虚拟化技术的基础上，对其中的安全机制进行原理学习与实践</p></blockquote><h3 id="知识大纲">知识大纲</h3><ol type="1"><li>预备知识（linux、虚拟化）</li><li>安全概念与标准</li><li>安全机制</li><li>安全模型</li><li>安全体系架构</li><li>安全开发方法</li><li>os安全增强</li><li>虚拟化安全增强</li></ol><h3 id="实践安排">实践安排</h3><p>基于os或者虚拟化的安全开发实践，推荐选题如下：</p><center><img src="https://cdn.jsdelivr.net/gh/AL-377/pic_bed/img/image-20230915111604479.png" alt="image-20230915111604479" style="zoom:33%;" /><br> 推荐的选题</center><!-- 参考内容 --><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://www.coursera.org/learn/os-virtsecurity#testimonials">Coursea课程</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>《Linux内核设计的艺术：图解操作系统架构设计与实现原理》<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PKU lessons</category>
      
      <category>PG-1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Virtualization</tag>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
